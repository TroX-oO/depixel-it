{"version":3,"sources":["../c0292686d4731ac1570e.worker.js","../webpack/bootstrap c0292686d4731ac1570e","worker/ImageProcessor.js","lib/Graph.js","helpers/Progressor.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_interopRequireDefault","obj","default","onProgress","step","percent","_Progressor2","progress","post","type","data","getProgression","createSimilarityGraph","width","height","g","_Graph2","j","current","rgb","r","b","nodes","x","y","addEdge","Math","floor","toYUV","ceil","u","v","match","rgb1","rgb2","removeDissimilarConnectedPixels","graph","length","edges","yuv1","dest","nodeId","yuv2","abs","console","log","removeEdge","computeCurveHeuristic","fromId","toId","stack","curve","push","pop","edge","indexOf","getbounds","x1","y1","x2","y2","xMin","min","yMin","xMax","yMax","inbounds","bounds","computeSparseHeuristic","component","neigh","neighId","node","computeIslandHeuristic","computeWeight","result","error","mostWeightDiagonals","origin","wFirst","wSecond","from","to","removeDiagonals","hasEdge","diag","reshape","gr","makeGrid","_nodes$i","id","px_x","max","px_y","offsetX","offsetY","adj_node","findNode","pn","mpn","npn","mpnNode","npnNode","pxNode","pnNode","removeCorner","addCorner","addNode","removals","_gr$nodes$_i","removeNode","clone","JSON","parse","stringify","corners","processImage","binaryData","serialize","reshapedGraph","handleMessage","e","binary","reset","image","done","_Graph","_Progressor","postMessage","onmessage","_classCallCheck","instance","Constructor","TypeError","findEdge","findNodeIdx","findCorner","cornerss","value","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","Id","Graph","size","this","Array","idx","splice","dir","fromNode","getNode","toNode","steps","title","Progressor","total","complete"],"mappings":"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","file":"c0292686d4731ac1570e.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/depixel-it/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nvar _Graph=__webpack_require__(1);var _Graph2=_interopRequireDefault(_Graph);var _Progressor=__webpack_require__(2);var _Progressor2=_interopRequireDefault(_Progressor);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}//$FlowFixMe\nvar post=postMessage;function onProgress(step,percent){if((step||step===0)&&(percent||percent===0)){_Progressor2.default.progress(step,percent);}post({type:'progress',data:_Progressor2.default.getProgression()});}function createSimilarityGraph(data,width,height){var g=new _Graph2.default(width*height,width,height);for(var j=0;j<height;j++){for(var i=0;i<width;i++){var current=j*width+i;var rgb={r:data[current*4],g:data[current*4+1],b:data[current*4+2]};// We set node color\ng.nodes[current].rgb=rgb;g.nodes[current].x=i;g.nodes[current].y=j;// Adding edges to horizontal/vertical neighbours\nif(i<width-1){// Right\ng.addEdge(current,current+1,'right');if(j>0){// Up Right\ng.addEdge(current,current-width+1,'upright');}if(j<height-1){// Down Right\ng.addEdge(current,current+width+1,'downright');}}if(i>0){// Left\ng.addEdge(current,current-1,'left');if(j>0){// Up Right\ng.addEdge(current,current-width-1,'upleft');}if(j<height-1){// Down Left\ng.addEdge(current,current+width-1,'downleft');}}if(j<height-1){// Down\ng.addEdge(current,current+width,'down');}if(j>0){// Up\ng.addEdge(current,current-width,'up');}onProgress(0,Math.floor(current/(height*width)*100));}}return g;}function toYUV(rgb){var y=Math.ceil(0.299*rgb.r+0.587*rgb.g+0.114*rgb.b);var u=Math.ceil(rgb.r*-0.168736+rgb.g*-0.331264+rgb.b*0.5+128);var v=Math.ceil(rgb.r*0.5+rgb.g*-0.418688+rgb.b*-0.081312+128);return{y:y,u:u,v:v};}function match(rgb1,rgb2){return rgb1.r===rgb2.r&&rgb1.g===rgb2.g&&rgb1.b===rgb2.b;// const yuv1 = toYUV(rgb1);\n// const yuv2 = toYUV(rgb2);\n// if (\n//   Math.abs(yuv1.y - yuv2.y) > 48 / 255 ||\n//   Math.abs(yuv1.u - yuv2.u) > 7 / 255 ||\n//   Math.abs(yuv1.v - yuv2.v) > 6 / 255\n// ) {\n//   return true;\n// }\n// return false;\n}function removeDissimilarConnectedPixels(graph){var nodes=graph.nodes;for(var i=0;i<nodes.length;++i){var edges=nodes[i].edges;var yuv1=toYUV(nodes[i].rgb);for(var j=0;j<edges.length;++j){var dest=nodes[edges[j].nodeId];var yuv2=toYUV(dest.rgb);if(Math.abs(yuv1.y-yuv2.y)>48/255||Math.abs(yuv1.u-yuv2.u)>7/255||Math.abs(yuv1.v-yuv2.v)>6/255){console.log('removing edges '+i+' -> '+edges[j].nodeId);graph.removeEdge(i,edges[j].nodeId);--j;}}}}function computeCurveHeuristic(graph,fromId,toId,width){var nodes=graph.nodes;var stack=[];var curve=[fromId+'-'+toId];stack.push(fromId);stack.push(toId);while(stack.length){var nodeId=stack.pop();var edges=nodes[nodeId].edges;// If we have more or less than 2 edges, then it's not part of a curve\nif(edges.length!==2){continue;}for(var i=0;i<edges.length;++i){var edge=edges[i];// If we have not seen this edge in the curve\nif(curve.indexOf(nodeId+'-'+edge.nodeId)===-1&&curve.indexOf(edge.nodeId+'-'+nodeId)===-1){// We add it to the stack\ncurve.push(nodeId+'-'+edge.nodeId);stack.push(edge.nodeId);}}}return curve.length;}// function neighbours(nodeId, width, height) {\n//   const result = [];\n//   const i = nodeId % width;\n//   const j = Math.floor(nodeId / width);\n//   if (i > 0) {\n//     result.push(i - 1);\n//     if (j > 0) {\n//       result.push(i - 1 - width);\n//     }\n//     if (j < height - 1) {\n//       result.push(i - 1 + width);\n//     }\n//   }\n//   if (i < width - 1) {\n//     result.push(i + 1);\n//     if (j > 0) {\n//       result.push(i + 1 - width);\n//     }\n//     if (j < height - 1) {\n//       result.push(i + 1 + width);\n//     }\n//   }\n//   if (j > 0) {\n//     result.push(i - width);\n//   }\n//   if (j < height - 1) {\n//     result.push(i + width);\n//   }\n//   return result;\n// }\nfunction getbounds(fromId,toId,width,height){var FrameSize=8;var x1=fromId%width;var y1=Math.floor(fromId/width);var x2=toId%width;var y2=Math.floor(toId/width);var xMin=-FrameSize/2-1+Math.min(x1,x2);var yMin=-FrameSize/2-1+Math.min(y1,y2);return{xMin:xMin,yMin:yMin,xMax:xMin+FrameSize,yMax:yMin+FrameSize};}function inbounds(bounds,x,y){var xMin=bounds.xMin,yMin=bounds.yMin,xMax=bounds.xMax,yMax=bounds.yMax;return x>=xMin&&x<=xMax&&y>=yMin&&y<=yMax;}function computeSparseHeuristic(graph,fromId,toId,width,height){var stack=[];var component=[fromId,toId];var bounds=getbounds(fromId,toId,width,height);stack.push(fromId);stack.push(toId);while(stack.length){var nodeId=stack.pop();var neigh=graph.nodes[nodeId].edges;for(var i=0;i<neigh.length;++i){var neighId=neigh[i].nodeId;if(component.indexOf(neighId)===-1){// If the node is within the 8x8 bounds\nvar node=graph.nodes[neighId];if(inbounds(bounds,node.x,node.y)){// We add it to the stack\ncomponent.push(neighId);stack.push(neighId);}}}}return-component.length;}function computeIslandHeuristic(graph,fromId,toId,width){var nodes=graph.nodes;if(nodes[fromId].edges.length===1||nodes[toId].edges.length===1){return 5;}return 0;}function computeWeight(graph,fromId,toId,width,height){var result=0;result+=computeCurveHeuristic(graph,fromId,toId,width);console.error('computeCurveHeuristic '+fromId+' '+toId);console.log(computeCurveHeuristic(graph,fromId,toId,width));result+=computeSparseHeuristic(graph,fromId,toId,width,height);console.error('computeSparseHeuristic '+fromId+' '+toId);console.log(computeSparseHeuristic(graph,fromId,toId,width,height));result+=computeIslandHeuristic(graph,fromId,toId,width);console.error('computeIslandHeuristic '+fromId+' '+toId);console.log(computeIslandHeuristic(graph,fromId,toId,width));return result;}function mostWeightDiagonals(graph,origin,width,height){var wFirst=computeWeight(graph,origin,origin+width+1,width,height);var wSecond=computeWeight(graph,origin+1,origin+width,width,height);if(wFirst>wSecond){console.error('winner first');return{from:origin+1,to:origin+width};}else if(wFirst<wSecond){console.error('winner second');return{from:origin,to:origin+width+1};}return null;}function removeDiagonals(graph,width,height){var nodes=graph.nodes;for(var i=0;i<nodes.length;++i){// We check if the 2x2 block is fully connected\n// Checking from current to the right/down/downright\n// Checking from current + 1 to down/downleft\n// checking from current + width to right\nif(graph.hasEdge(i,i+1)&&graph.hasEdge(i,i+width)&&graph.hasEdge(i,i+width+1)&&graph.hasEdge(i+1,i+width)&&graph.hasEdge(i+1,i+width+1)&&graph.hasEdge(i+width,i+width+1)){// We remove diagonales\ngraph.removeEdge(i,i+width+1);graph.removeEdge(i+1,i+width);}else if(!graph.hasEdge(i,i+1)&&!graph.hasEdge(i,i+width)&&graph.hasEdge(i,i+width+1)&&graph.hasEdge(i+1,i+width)&&!graph.hasEdge(i+1,i+width+1)&&!graph.hasEdge(i+width,i+width+1)){// Diagonals only, we need to resolve ambiguous meaning\nvar diag=mostWeightDiagonals(graph,i,width,height);if(diag){// We remove the most weighted diag\ngraph.removeEdge(diag.from,diag.to);}else{// If it's a tie, we remove both\ngraph.removeEdge(i,i+width+1);graph.removeEdge(i+1,i+width);}}}}function reshape(graph,width,height){var gr=new _Graph2.default((width+1)*(height+1),width+1,height+1);var nodes=graph.nodes;gr.makeGrid(width,height);for(var i=0;i<nodes.length;++i){var _nodes$i=nodes[i],edges=_nodes$i.edges,x=_nodes$i.x,y=_nodes$i.y,rgb=_nodes$i.rgb,id=_nodes$i.id;// we don't process corners\nif(x===0&&y===0||x===0&&y===height-1||x===width-1&&y===0||x===width-1&&y===height-1){continue;}for(var j=0;j<edges.length;++j){var edge=edges[j];var to=nodes[edge.nodeId];// We check only diagonals\nif(x===to.x||y===to.y){continue;}var px_x=Math.max(to.x,x);var px_y=Math.max(to.y,y);var offsetX=to.x-x;var offsetY=to.y-y;// Adj node = to.x, y\nvar adj_node=graph.findNode(to.x,y);var pn=null;var mpn=null;var npn=null;var mpnNode=null;var npnNode=null;var pxNode=null;var pnNode=null;if(!match(rgb,adj_node.rgb)){pn=[px_x,px_y-offsetY];mpn=[px_x,px_y-0.5*offsetY];npn=[px_x+0.25*offsetX,px_y-0.25*offsetY];graph.removeCorner(adj_node.id,px_x,px_y);graph.addCorner(adj_node.id,npn[0],npn[1]);graph.addCorner(id,npn[0],npn[1]);mpnNode=gr.findNode(mpn[0],mpn[1]);npnNode=gr.findNode(npn[0],npn[1]);pxNode=gr.findNode(px_x,px_y);if(mpnNode){gr.removeEdge(mpnNode.id,pxNode.id);}else{pnNode=gr.findNode(pn[0],pn[1]);gr.removeEdge(pnNode.id,pxNode.id);mpnNode=gr.addNode(mpn[0],mpn[1]);gr.addEdge(pnNode.id,mpnNode.id);}if(!npnNode){npnNode=gr.addNode(npn[0],npn[1]);}gr.addEdge(mpnNode.id,npnNode.id);gr.addEdge(npnNode.id,pxNode.id);}// Adj node = to.x, y\nadj_node=graph.findNode(x,to.y);if(!match(rgb,adj_node.rgb)){pn=[px_x-offsetX,px_y];mpn=[px_x-0.5*offsetX,px_y];npn=[px_x-0.25*offsetX,px_y+0.25*offsetY];graph.removeCorner(adj_node.id,px_x,px_y);graph.addCorner(adj_node.id,npn[0],npn[1]);graph.addCorner(id,npn[0],npn[1]);mpnNode=gr.findNode(mpn[0],mpn[1]);npnNode=gr.findNode(npn[0],npn[1]);pxNode=gr.findNode(px_x,px_y);if(mpnNode){gr.removeEdge(mpnNode.id,pxNode.id);}else{pnNode=gr.findNode(pn[0],pn[1]);gr.removeEdge(pnNode.id,pxNode.id);mpnNode=gr.addNode(mpn[0],mpn[1]);gr.addEdge(pnNode.id,mpnNode.id);}if(!npnNode){npnNode=gr.addNode(npn[0],npn[1]);}gr.addEdge(mpnNode.id,npnNode.id);gr.addEdge(npnNode.id,pxNode.id);}}}// We optimize the graph by removing 2-valences nodes\nvar removals=[];for(var _i=0;_i<gr.nodes.length;++_i){var _gr$nodes$_i=gr.nodes[_i],edges=_gr$nodes$_i.edges,x=_gr$nodes$_i.x,y=_gr$nodes$_i.y,id=_gr$nodes$_i.id;if(x===0&&y===0||x===0&&y===height||x===width&&y===0||x===width&&y===height){continue;}if(edges.length===2){gr.addEdge(edges[0].nodeId,edges[1].nodeId);}if(edges.length<=2){removals.push(id);}}for(var _i2=0;_i2<removals.length;++_i2){gr.removeNode(removals[_i2]);}// Copying corners\nfor(var _i3=0;_i3<nodes.length;++_i3){var clone=JSON.parse(JSON.stringify(nodes[_i3].corners));for(var _j=0;_j<clone.length;++_j){if(!gr.findNode(clone[_j].x,clone[_j].y)){graph.removeCorner(_i3,clone[_j].x,clone[_j].y);}}}return gr;}function processImage(binaryData,width,height){var graph=createSimilarityGraph(binaryData,width,height);post({type:'step',data:{type:'initial',graph:graph.serialize()}});removeDissimilarConnectedPixels(graph);post({type:'step',data:{type:'initial',graph:graph.serialize()}});removeDiagonals(graph,width,height);post({type:'step',data:{type:'initial',graph:graph.serialize()}});var reshapedGraph=reshape(graph,width,height);post({type:'step',data:{type:'reshaped',graph:reshapedGraph.serialize()}});post({type:'step',data:{type:'initial',graph:graph.serialize()}});}function handleMessage(e){var width=e.data.width;var height=e.data.height;var binary=e.data.data;console.log('Message received from main script.');console.log(e.data);_Progressor2.default.reset();processImage(binary,width,height);post({type:'step',data:{type:'final',image:binary}});_Progressor2.default.done();onProgress();// post({\n//   type: 'done',\n//   data: binary\n// });\n}onmessage=handleMessage;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function findEdge(node,toId){for(var i=0;i<node.length;++i){if(node[i].nodeId===toId){return i;}}return-1;}function findNodeIdx(nodes,nodeId){for(var i=0;i<nodes.length;++i){if(nodes[i].id===nodeId){return i;}}return-1;}function findCorner(cornerss,x,y){for(var i=0;i<cornerss.length;++i){if(cornerss[i].x===x&&cornerss[i].y===y){return i;}}return-1;}var Id=0;var Graph=function(){function Graph(size,width,height){_classCallCheck(this,Graph);this.id=++Id;this.nodes=new Array(size);this.width=width;this.height=height;for(var i=0;i<this.nodes.length;++i){var _x=i%width;var _y=Math.floor(i/width);this.nodes[i]={id:i,edges:[],rgb:null,x:-1,y:-1,corners:[{x:_x,y:_y}]};if(_x<width){this.nodes[i].corners.push({x:_x+1,y:_y});}if(_y<height){this.nodes[i].corners.push({x:_x,y:_y+1});}if(_x<width&&_y<height){this.nodes[i].corners.push({x:_x+1,y:_y+1});}}}_createClass(Graph,[{key:'makeGrid',value:function makeGrid(width,height){var nodes=this.nodes;for(var i=0;i<nodes.length;++i){var _x2=i%(width+1);var _y2=Math.floor(i/(width+1));nodes[i].x=_x2;nodes[i].y=_y2;nodes[i].corners=[];console.log(''+_x2+_y2);if(_x2<width){this.addEdge(i,i+1,'right');}if(_y2<height){this.addEdge(i,i+(width+1),'down');}}}},{key:'addNode',value:function addNode(x,y){var n=this.findNode(x,y);if(!n){n={id:this.nodes.length,edges:[],rgb:null,x:x,y:y,corners:[]};this.nodes.push(n);}return n;}},{key:'removeNode',value:function removeNode(nodeId){var idx=findNodeIdx(this.nodes,nodeId);if(idx!==-1){var node=this.nodes[idx];while(node.edges.length){this.removeEdge(nodeId,node.edges[0].nodeId);}this.nodes.splice(idx,1);}}},{key:'findNode',value:function findNode(x,y){for(var i=0;i<this.nodes.length;++i){if(this.nodes[i].x===x&&this.nodes[i].y===y){return this.nodes[i];}}return null;}},{key:'getNode',value:function getNode(nodeId){for(var i=0;i<this.nodes.length;++i){if(this.nodes[i].id===nodeId){return this.nodes[i];}}return null;}},{key:'addEdge',value:function addEdge(fromId,toId,dir,data){var fromNode=this.getNode(fromId);var toNode=this.getNode(toId);if(fromNode&&findEdge(fromNode.edges,toId)===-1){fromNode.edges.push({nodeId:toId,dir:dir,data:data});}if(toNode&&findEdge(toNode.edges,fromId)===-1){var invert=function invert(dir){if(dir==='up')return'down';if(dir==='down')return'up';if(dir==='left')return'right';if(dir==='right')return'left';if(dir==='upright')return'downleft';if(dir==='upleft')return'downright';if(dir==='downleft')return'upright';if(dir==='downright')return'upleft';};toNode.edges.push({nodeId:fromId,dir:invert(dir),data:data});}}},{key:'removeEdge',value:function removeEdge(fromId,toId){var fromNode=this.getNode(fromId);var toNode=this.getNode(toId);if(fromNode){var idx=findEdge(fromNode.edges,toId);if(idx!==-1){fromNode.edges.splice(idx,1);}}if(toNode){var _idx=findEdge(toNode.edges,fromId);if(_idx!==-1){toNode.edges.splice(_idx,1);}}}},{key:'hasEdge',value:function hasEdge(fromId,toId){var fromNode=this.getNode(fromId);// console.log(`hasEdge from ${fromId} to ${toId} ? ${(findEdge(this.nodes[fromId].edges, toId) !== -1).toString()}`);\nreturn findEdge(fromNode.edges,toId)!==-1;}},{key:'removeCorner',value:function removeCorner(nodeId,x,y){var node=this.getNode(nodeId);if(node){var idx=findCorner(node.corners,x,y);if(idx!==-1){node.corners.splice(idx,1);}}}},{key:'addCorner',value:function addCorner(nodeId,x,y){var node=this.getNode(nodeId);if(node){node.corners.push({x:x,y:y});}}},{key:'serialize',value:function serialize(){// for (let i = 0; i < this.nodes.length; ++i) {\n//   console.log(`Node ${i}`);\n//   for (let j = 0; j < this.nodes[i].edges.length; ++j) {\n//     const node = this.nodes[i].edges[j];\n//     console.log(`  Edge -> ${node.nodeId} ${node.data ? `(${JSON.stringify(node.data)})` : ''}`);\n//   }\n// }\nreturn JSON.stringify({nodes:this.nodes,width:this.width,height:this.height});}}],[{key:'unserialize',value:function unserialize(data){var d=JSON.parse(data);var g=new Graph(d.nodes.length,d.width,d.height);g.nodes=d.nodes;return g;}}]);return Graph;}();exports.default=Graph;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});var steps=[{title:'Generating similarity graph',progress:0},{title:'Resolving ambiguous diagonals',progress:0},{title:'Computing reshaped graph',progress:0}];var Progressor={};Progressor.reset=function(){for(var i=0;i<steps.length;++i){steps[i].progress=0;}};Progressor.progress=function(step,percent){if(steps[step]){steps[step].progress=percent;}};Progressor.done=function(){for(var i=0;i<steps.length;++i){steps[i].progress=100;}};Progressor.getProgression=function(){var p=0;var title=null;for(var i=0;i<steps.length;++i){p+=steps[i].progress;if(!title&&steps[i].progress!==100){title=steps[i].title;}}var total=Math.floor(p/steps.length);return{title:total===100?'':title||steps[0].title,percent:total,complete:total===100};};exports.default=Progressor;\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// c0292686d4731ac1570e.worker.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/depixel-it/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c0292686d4731ac1570e","import Graph from '../lib/Graph';\r\nimport Progressor from '../helpers/Progressor';\r\n\r\n//@flow\r\n\r\n//$FlowFixMe\r\nconst post = postMessage;\r\n\r\nfunction onProgress(step?: number, percent?: number) {\r\n  if ((step || step === 0) && (percent || percent === 0)) {\r\n    Progressor.progress(step, percent);\r\n  }\r\n\r\n  post({\r\n    type: 'progress',\r\n    data: Progressor.getProgression()\r\n  });\r\n}\r\n\r\nfunction createSimilarityGraph(data, width, height) {\r\n  const g = new Graph(width * height, width, height);\r\n\r\n  for (let j = 0; j < height; j++) {\r\n    for (let i = 0; i < width; i++) {\r\n      const current = j * width + i;\r\n      const rgb = {\r\n        r: data[current * 4],\r\n        g: data[current * 4 + 1],\r\n        b: data[current * 4 + 2]\r\n      };\r\n\r\n      // We set node color\r\n      g.nodes[current].rgb = rgb;\r\n      g.nodes[current].x = i;\r\n      g.nodes[current].y = j;\r\n\r\n      // Adding edges to horizontal/vertical neighbours\r\n      if (i < width - 1) {\r\n        // Right\r\n        g.addEdge(current, current + 1, 'right');\r\n\r\n        if (j > 0) {\r\n          // Up Right\r\n          g.addEdge(current, current - width + 1, 'upright');\r\n        }\r\n        if (j < height - 1) {\r\n          // Down Right\r\n          g.addEdge(current, current + width + 1, 'downright');\r\n        }\r\n      }\r\n      if (i > 0) {\r\n        // Left\r\n        g.addEdge(current, current - 1, 'left');\r\n\r\n        if (j > 0) {\r\n          // Up Right\r\n          g.addEdge(current, current - width - 1, 'upleft');\r\n        }\r\n        if (j < height - 1) {\r\n          // Down Left\r\n          g.addEdge(current, current + width - 1, 'downleft');\r\n        }\r\n      }\r\n\r\n      if (j < height - 1) {\r\n        // Down\r\n        g.addEdge(current, current + width, 'down');\r\n      }\r\n      if (j > 0) {\r\n        // Up\r\n        g.addEdge(current, current - width, 'up');\r\n      }\r\n      onProgress(0, Math.floor(current / (height * width) * 100));\r\n    }\r\n  }\r\n\r\n  return g;\r\n}\r\n\r\nfunction toYUV(rgb: Object) {\r\n  const y = Math.ceil(0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b);\r\n  const u = Math.ceil(rgb.r * -0.168736 + rgb.g * -0.331264 + rgb.b * 0.5 + 128);\r\n  const v = Math.ceil(rgb.r * 0.5 + rgb.g * -0.418688 + rgb.b * -0.081312 + 128);\r\n\r\n  return {\r\n    y,\r\n    u,\r\n    v\r\n  };\r\n}\r\n\r\nfunction match(rgb1, rgb2) {\r\n  return rgb1.r === rgb2.r && rgb1.g === rgb2.g && rgb1.b === rgb2.b;\r\n\r\n  // const yuv1 = toYUV(rgb1);\r\n  // const yuv2 = toYUV(rgb2);\r\n\r\n  // if (\r\n  //   Math.abs(yuv1.y - yuv2.y) > 48 / 255 ||\r\n  //   Math.abs(yuv1.u - yuv2.u) > 7 / 255 ||\r\n  //   Math.abs(yuv1.v - yuv2.v) > 6 / 255\r\n  // ) {\r\n  //   return true;\r\n  // }\r\n  // return false;\r\n}\r\n\r\nfunction removeDissimilarConnectedPixels(graph) {\r\n  const { nodes } = graph;\r\n\r\n  for (let i = 0; i < nodes.length; ++i) {\r\n    const edges = nodes[i].edges;\r\n    const yuv1 = toYUV(nodes[i].rgb);\r\n\r\n    for (let j = 0; j < edges.length; ++j) {\r\n      const dest = nodes[edges[j].nodeId];\r\n      const yuv2 = toYUV(dest.rgb);\r\n\r\n      if (\r\n        Math.abs(yuv1.y - yuv2.y) > 48 / 255 ||\r\n        Math.abs(yuv1.u - yuv2.u) > 7 / 255 ||\r\n        Math.abs(yuv1.v - yuv2.v) > 6 / 255\r\n      ) {\r\n        console.log(`removing edges ${i} -> ${edges[j].nodeId}`);\r\n        graph.removeEdge(i, edges[j].nodeId);\r\n        --j;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction computeCurveHeuristic(graph, fromId, toId, width) {\r\n  const { nodes } = graph;\r\n  const stack = [];\r\n  const curve = [`${fromId}-${toId}`];\r\n\r\n  stack.push(fromId);\r\n  stack.push(toId);\r\n\r\n  while (stack.length) {\r\n    const nodeId = stack.pop();\r\n    const { edges } = nodes[nodeId];\r\n\r\n    // If we have more or less than 2 edges, then it's not part of a curve\r\n    if (edges.length !== 2) {\r\n      continue;\r\n    }\r\n\r\n    for (let i = 0; i < edges.length; ++i) {\r\n      const edge = edges[i];\r\n\r\n      // If we have not seen this edge in the curve\r\n      if (curve.indexOf(`${nodeId}-${edge.nodeId}`) === -1 && curve.indexOf(`${edge.nodeId}-${nodeId}`) === -1) {\r\n        // We add it to the stack\r\n        curve.push(`${nodeId}-${edge.nodeId}`);\r\n        stack.push(edge.nodeId);\r\n      }\r\n    }\r\n  }\r\n  return curve.length;\r\n}\r\n\r\n// function neighbours(nodeId, width, height) {\r\n//   const result = [];\r\n//   const i = nodeId % width;\r\n//   const j = Math.floor(nodeId / width);\r\n\r\n//   if (i > 0) {\r\n//     result.push(i - 1);\r\n\r\n//     if (j > 0) {\r\n//       result.push(i - 1 - width);\r\n//     }\r\n\r\n//     if (j < height - 1) {\r\n//       result.push(i - 1 + width);\r\n//     }\r\n//   }\r\n\r\n//   if (i < width - 1) {\r\n//     result.push(i + 1);\r\n\r\n//     if (j > 0) {\r\n//       result.push(i + 1 - width);\r\n//     }\r\n\r\n//     if (j < height - 1) {\r\n//       result.push(i + 1 + width);\r\n//     }\r\n//   }\r\n\r\n//   if (j > 0) {\r\n//     result.push(i - width);\r\n//   }\r\n\r\n//   if (j < height - 1) {\r\n//     result.push(i + width);\r\n//   }\r\n//   return result;\r\n// }\r\n\r\nfunction getbounds(fromId, toId, width, height) {\r\n  const FrameSize = 8;\r\n  const x1 = fromId % width;\r\n  const y1 = Math.floor(fromId / width);\r\n  const x2 = toId % width;\r\n  const y2 = Math.floor(toId / width);\r\n  const xMin = -FrameSize / 2 - 1 + Math.min(x1, x2);\r\n  const yMin = -FrameSize / 2 - 1 + Math.min(y1, y2);\r\n\r\n  return {\r\n    xMin,\r\n    yMin,\r\n    xMax: xMin + FrameSize,\r\n    yMax: yMin + FrameSize\r\n  };\r\n}\r\n\r\nfunction inbounds(bounds, x, y) {\r\n  const { xMin, yMin, xMax, yMax } = bounds;\r\n\r\n  return x >= xMin && x <= xMax && y >= yMin && y <= yMax;\r\n}\r\n\r\nfunction computeSparseHeuristic(graph, fromId, toId, width, height) {\r\n  const stack = [];\r\n  const component = [fromId, toId];\r\n  const bounds = getbounds(fromId, toId, width, height);\r\n\r\n  stack.push(fromId);\r\n  stack.push(toId);\r\n\r\n  while (stack.length) {\r\n    const nodeId = stack.pop();\r\n    const neigh = graph.nodes[nodeId].edges;\r\n\r\n    for (let i = 0; i < neigh.length; ++i) {\r\n      const neighId = neigh[i].nodeId;\r\n\r\n      if (component.indexOf(neighId) === -1) {\r\n        // If the node is within the 8x8 bounds\r\n        const node = graph.nodes[neighId];\r\n        if (inbounds(bounds, node.x, node.y)) {\r\n          // We add it to the stack\r\n          component.push(neighId);\r\n          stack.push(neighId);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return -component.length;\r\n}\r\n\r\nfunction computeIslandHeuristic(graph, fromId, toId, width) {\r\n  const { nodes } = graph;\r\n\r\n  if (nodes[fromId].edges.length === 1 || nodes[toId].edges.length === 1) {\r\n    return 5;\r\n  }\r\n  return 0;\r\n}\r\n\r\nfunction computeWeight(graph, fromId, toId, width, height) {\r\n  let result = 0;\r\n\r\n  result += computeCurveHeuristic(graph, fromId, toId, width);\r\n  console.error(`computeCurveHeuristic ${fromId} ${toId}`);\r\n  console.log(computeCurveHeuristic(graph, fromId, toId, width));\r\n  result += computeSparseHeuristic(graph, fromId, toId, width, height);\r\n  console.error(`computeSparseHeuristic ${fromId} ${toId}`);\r\n  console.log(computeSparseHeuristic(graph, fromId, toId, width, height));\r\n  result += computeIslandHeuristic(graph, fromId, toId, width);\r\n  console.error(`computeIslandHeuristic ${fromId} ${toId}`);\r\n  console.log(computeIslandHeuristic(graph, fromId, toId, width));\r\n\r\n  return result;\r\n}\r\n\r\nfunction mostWeightDiagonals(graph, origin, width, height) {\r\n  const wFirst = computeWeight(graph, origin, origin + width + 1, width, height);\r\n  const wSecond = computeWeight(graph, origin + 1, origin + width, width, height);\r\n\r\n  if (wFirst > wSecond) {\r\n    console.error(`winner first`);\r\n    return {\r\n      from: origin + 1,\r\n      to: origin + width\r\n    };\r\n  } else if (wFirst < wSecond) {\r\n    console.error(`winner second`);\r\n    return {\r\n      from: origin,\r\n      to: origin + width + 1\r\n    };\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction removeDiagonals(graph, width, height) {\r\n  const { nodes } = graph;\r\n\r\n  for (let i = 0; i < nodes.length; ++i) {\r\n    // We check if the 2x2 block is fully connected\r\n    // Checking from current to the right/down/downright\r\n    // Checking from current + 1 to down/downleft\r\n    // checking from current + width to right\r\n    if (\r\n      graph.hasEdge(i, i + 1) &&\r\n      graph.hasEdge(i, i + width) &&\r\n      graph.hasEdge(i, i + width + 1) &&\r\n      graph.hasEdge(i + 1, i + width) &&\r\n      graph.hasEdge(i + 1, i + width + 1) &&\r\n      graph.hasEdge(i + width, i + width + 1)\r\n    ) {\r\n      // We remove diagonales\r\n      graph.removeEdge(i, i + width + 1);\r\n      graph.removeEdge(i + 1, i + width);\r\n    } else if (\r\n      !graph.hasEdge(i, i + 1) &&\r\n      !graph.hasEdge(i, i + width) &&\r\n      graph.hasEdge(i, i + width + 1) &&\r\n      graph.hasEdge(i + 1, i + width) &&\r\n      !graph.hasEdge(i + 1, i + width + 1) &&\r\n      !graph.hasEdge(i + width, i + width + 1)\r\n    ) {\r\n      // Diagonals only, we need to resolve ambiguous meaning\r\n      const diag = mostWeightDiagonals(graph, i, width, height);\r\n\r\n      if (diag) {\r\n        // We remove the most weighted diag\r\n        graph.removeEdge(diag.from, diag.to);\r\n      } else {\r\n        // If it's a tie, we remove both\r\n        graph.removeEdge(i, i + width + 1);\r\n        graph.removeEdge(i + 1, i + width);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction reshape(graph, width, height) {\r\n  const gr = new Graph((width + 1) * (height + 1), width + 1, height + 1);\r\n  const { nodes } = graph;\r\n\r\n  gr.makeGrid(width, height);\r\n\r\n  for (let i = 0; i < nodes.length; ++i) {\r\n    const { edges, x, y, rgb, id } = nodes[i];\r\n\r\n    // we don't process corners\r\n    if (\r\n      (x === 0 && y === 0) ||\r\n      (x === 0 && y === height - 1) ||\r\n      (x === width - 1 && y === 0) ||\r\n      (x === width - 1 && y === height - 1)\r\n    ) {\r\n      continue;\r\n    }\r\n\r\n    for (let j = 0; j < edges.length; ++j) {\r\n      const edge = edges[j];\r\n      const to = nodes[edge.nodeId];\r\n\r\n      // We check only diagonals\r\n      if (x === to.x || y === to.y) {\r\n        continue;\r\n      }\r\n\r\n      const px_x = Math.max(to.x, x);\r\n      const px_y = Math.max(to.y, y);\r\n      const offsetX = to.x - x;\r\n      const offsetY = to.y - y;\r\n\r\n      // Adj node = to.x, y\r\n      let adj_node = graph.findNode(to.x, y);\r\n\r\n      let pn = null;\r\n      let mpn = null;\r\n      let npn = null;\r\n      let mpnNode = null;\r\n      let npnNode = null;\r\n      let pxNode = null;\r\n      let pnNode = null;\r\n\r\n      if (!match(rgb, adj_node.rgb)) {\r\n        pn = [px_x, px_y - offsetY];\r\n        mpn = [px_x, px_y - 0.5 * offsetY];\r\n        npn = [px_x + 0.25 * offsetX, px_y - 0.25 * offsetY];\r\n\r\n        graph.removeCorner(adj_node.id, px_x, px_y);\r\n        graph.addCorner(adj_node.id, npn[0], npn[1]);\r\n        graph.addCorner(id, npn[0], npn[1]);\r\n\r\n        mpnNode = gr.findNode(mpn[0], mpn[1]);\r\n        npnNode = gr.findNode(npn[0], npn[1]);\r\n        pxNode = gr.findNode(px_x, px_y);\r\n\r\n        if (mpnNode) {\r\n          gr.removeEdge(mpnNode.id, pxNode.id);\r\n        } else {\r\n          pnNode = gr.findNode(pn[0], pn[1]);\r\n\r\n          gr.removeEdge(pnNode.id, pxNode.id);\r\n          mpnNode = gr.addNode(mpn[0], mpn[1]);\r\n          gr.addEdge(pnNode.id, mpnNode.id);\r\n        }\r\n        if (!npnNode) {\r\n          npnNode = gr.addNode(npn[0], npn[1]);\r\n        }\r\n        gr.addEdge(mpnNode.id, npnNode.id);\r\n        gr.addEdge(npnNode.id, pxNode.id);\r\n      }\r\n\r\n      // Adj node = to.x, y\r\n      adj_node = graph.findNode(x, to.y);\r\n\r\n      if (!match(rgb, adj_node.rgb)) {\r\n        pn = [px_x - offsetX, px_y];\r\n        mpn = [px_x - 0.5 * offsetX, px_y];\r\n        npn = [px_x - 0.25 * offsetX, px_y + 0.25 * offsetY];\r\n\r\n        graph.removeCorner(adj_node.id, px_x, px_y);\r\n        graph.addCorner(adj_node.id, npn[0], npn[1]);\r\n        graph.addCorner(id, npn[0], npn[1]);\r\n\r\n        mpnNode = gr.findNode(mpn[0], mpn[1]);\r\n        npnNode = gr.findNode(npn[0], npn[1]);\r\n        pxNode = gr.findNode(px_x, px_y);\r\n\r\n        if (mpnNode) {\r\n          gr.removeEdge(mpnNode.id, pxNode.id);\r\n        } else {\r\n          pnNode = gr.findNode(pn[0], pn[1]);\r\n\r\n          gr.removeEdge(pnNode.id, pxNode.id);\r\n          mpnNode = gr.addNode(mpn[0], mpn[1]);\r\n          gr.addEdge(pnNode.id, mpnNode.id);\r\n        }\r\n        if (!npnNode) {\r\n          npnNode = gr.addNode(npn[0], npn[1]);\r\n        }\r\n        gr.addEdge(mpnNode.id, npnNode.id);\r\n        gr.addEdge(npnNode.id, pxNode.id);\r\n      }\r\n    }\r\n  }\r\n\r\n  // We optimize the graph by removing 2-valences nodes\r\n  const removals = [];\r\n\r\n  for (let i = 0; i < gr.nodes.length; ++i) {\r\n    const { edges, x, y, id } = gr.nodes[i];\r\n\r\n    if (\r\n      (x === 0 && y === 0) ||\r\n      (x === 0 && y === height) ||\r\n      (x === width && y === 0) ||\r\n      (x === width && y === height)\r\n    ) {\r\n      continue;\r\n    }\r\n\r\n    if (edges.length === 2) {\r\n      gr.addEdge(edges[0].nodeId, edges[1].nodeId);\r\n    }\r\n    if (edges.length <= 2) {\r\n      removals.push(id);\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < removals.length; ++i) {\r\n    gr.removeNode(removals[i]);\r\n  }\r\n\r\n  // Copying corners\r\n  for (let i = 0; i < nodes.length; ++i) {\r\n    const clone = JSON.parse(JSON.stringify(nodes[i].corners));\r\n\r\n    for (let j = 0; j < clone.length; ++j) {\r\n      if (!gr.findNode(clone[j].x, clone[j].y)) {\r\n        graph.removeCorner(i, clone[j].x, clone[j].y);\r\n      }\r\n    }\r\n  }\r\n\r\n  return gr;\r\n}\r\n\r\nfunction processImage(binaryData, width, height) {\r\n  const graph = createSimilarityGraph(binaryData, width, height);\r\n\r\n  post({\r\n    type: 'step',\r\n    data: {\r\n      type: 'initial',\r\n      graph: graph.serialize()\r\n    }\r\n  });\r\n\r\n  removeDissimilarConnectedPixels(graph);\r\n\r\n  post({\r\n    type: 'step',\r\n    data: {\r\n      type: 'initial',\r\n      graph: graph.serialize()\r\n    }\r\n  });\r\n\r\n  removeDiagonals(graph, width, height);\r\n\r\n  post({\r\n    type: 'step',\r\n    data: {\r\n      type: 'initial',\r\n      graph: graph.serialize()\r\n    }\r\n  });\r\n\r\n  const reshapedGraph = reshape(graph, width, height);\r\n\r\n  post({\r\n    type: 'step',\r\n    data: {\r\n      type: 'reshaped',\r\n      graph: reshapedGraph.serialize()\r\n    }\r\n  });\r\n  post({\r\n    type: 'step',\r\n    data: {\r\n      type: 'initial',\r\n      graph: graph.serialize()\r\n    }\r\n  });\r\n}\r\n\r\nfunction handleMessage(e: any) {\r\n  const width = e.data.width;\r\n  const height = e.data.height;\r\n  const binary = e.data.data;\r\n  console.log('Message received from main script.');\r\n  console.log(e.data);\r\n\r\n  Progressor.reset();\r\n\r\n  processImage(binary, width, height);\r\n  post({\r\n    type: 'step',\r\n    data: {\r\n      type: 'final',\r\n      image: binary\r\n    }\r\n  });\r\n  Progressor.done();\r\n  onProgress();\r\n  // post({\r\n  //   type: 'done',\r\n  //   data: binary\r\n  // });\r\n}\r\n\r\nonmessage = handleMessage;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/worker/ImageProcessor.js","//@flow\r\n\r\nfunction findEdge(node: Array<Object>, toId: number) {\r\n  for (let i = 0; i < node.length; ++i) {\r\n    if (node[i].nodeId === toId) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n\r\nfunction findNodeIdx(nodes: Array<Object>, nodeId: number) {\r\n  for (let i = 0; i < nodes.length; ++i) {\r\n    if (nodes[i].id === nodeId) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n\r\nfunction findCorner(cornerss: Array<Object>, x: number, y: number) {\r\n  for (let i = 0; i < cornerss.length; ++i) {\r\n    if (cornerss[i].x === x && cornerss[i].y === y) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n\r\nlet Id = 0;\r\n\r\nexport default class Graph {\r\n  id: number;\r\n  nodes: Array<{\r\n    id: number,\r\n    edges: Array<Object>,\r\n    corners: Array<Object>,\r\n    rgb: ?Object,\r\n    x: number,\r\n    y: number\r\n  }>;\r\n  width: number;\r\n  height: number;\r\n\r\n  constructor(size: number, width: number, height: number) {\r\n    this.id = ++Id;\r\n    this.nodes = new Array(size);\r\n    this.width = width;\r\n    this.height = height;\r\n\r\n    for (let i = 0; i < this.nodes.length; ++i) {\r\n      const x = i % width;\r\n      const y = Math.floor(i / width);\r\n      this.nodes[i] = { id: i, edges: [], rgb: null, x: -1, y: -1, corners: [{ x, y }] };\r\n\r\n      if (x < width) {\r\n        this.nodes[i].corners.push({ x: x + 1, y: y });\r\n      }\r\n      if (y < height) {\r\n        this.nodes[i].corners.push({ x: x, y: y + 1 });\r\n      }\r\n\r\n      if (x < width && y < height) {\r\n        this.nodes[i].corners.push({ x: x + 1, y: y + 1 });\r\n      }\r\n    }\r\n  }\r\n\r\n  makeGrid(width: number, height: number) {\r\n    const { nodes } = this;\r\n\r\n    for (let i = 0; i < nodes.length; ++i) {\r\n      const x = i % (width + 1);\r\n      const y = Math.floor(i / (width + 1));\r\n\r\n      nodes[i].x = x;\r\n      nodes[i].y = y;\r\n\r\n      nodes[i].corners = [];\r\n\r\n      console.log(`${x}${y}`);\r\n      if (x < width) {\r\n        this.addEdge(i, i + 1, 'right');\r\n      }\r\n      if (y < height) {\r\n        this.addEdge(i, i + (width + 1), 'down');\r\n      }\r\n    }\r\n  }\r\n\r\n  addNode(x: number, y: number) {\r\n    let n = this.findNode(x, y);\r\n\r\n    if (!n) {\r\n      n = { id: this.nodes.length, edges: [], rgb: null, x, y, corners: [] };\r\n\r\n      this.nodes.push(n);\r\n    }\r\n    return n;\r\n  }\r\n\r\n  removeNode(nodeId: number) {\r\n    const idx = findNodeIdx(this.nodes, nodeId);\r\n\r\n    if (idx !== -1) {\r\n      const node = this.nodes[idx];\r\n\r\n      while (node.edges.length) {\r\n        this.removeEdge(nodeId, node.edges[0].nodeId);\r\n      }\r\n\r\n      this.nodes.splice(idx, 1);\r\n    }\r\n  }\r\n\r\n  findNode(x: number, y: number) {\r\n    for (let i = 0; i < this.nodes.length; ++i) {\r\n      if (this.nodes[i].x === x && this.nodes[i].y === y) {\r\n        return this.nodes[i];\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  getNode(nodeId: number) {\r\n    for (let i = 0; i < this.nodes.length; ++i) {\r\n      if (this.nodes[i].id === nodeId) {\r\n        return this.nodes[i];\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  addEdge(fromId: number, toId: number, dir: string, data: any) {\r\n    const fromNode = this.getNode(fromId);\r\n    const toNode = this.getNode(toId);\r\n\r\n    if (fromNode && findEdge(fromNode.edges, toId) === -1) {\r\n      fromNode.edges.push({ nodeId: toId, dir, data });\r\n    }\r\n    if (toNode && findEdge(toNode.edges, fromId) === -1) {\r\n      const invert = dir => {\r\n        if (dir === 'up') return 'down';\r\n        if (dir === 'down') return 'up';\r\n        if (dir === 'left') return 'right';\r\n        if (dir === 'right') return 'left';\r\n        if (dir === 'upright') return 'downleft';\r\n        if (dir === 'upleft') return 'downright';\r\n        if (dir === 'downleft') return 'upright';\r\n        if (dir === 'downright') return 'upleft';\r\n      };\r\n      toNode.edges.push({ nodeId: fromId, dir: invert(dir), data });\r\n    }\r\n  }\r\n\r\n  removeEdge(fromId: number, toId: number) {\r\n    const fromNode = this.getNode(fromId);\r\n    const toNode = this.getNode(toId);\r\n\r\n    if (fromNode) {\r\n      const idx = findEdge(fromNode.edges, toId);\r\n\r\n      if (idx !== -1) {\r\n        fromNode.edges.splice(idx, 1);\r\n      }\r\n    }\r\n\r\n    if (toNode) {\r\n      const idx = findEdge(toNode.edges, fromId);\r\n\r\n      if (idx !== -1) {\r\n        toNode.edges.splice(idx, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  hasEdge(fromId: number, toId: number) {\r\n    const fromNode = this.getNode(fromId);\r\n    // console.log(`hasEdge from ${fromId} to ${toId} ? ${(findEdge(this.nodes[fromId].edges, toId) !== -1).toString()}`);\r\n    return findEdge(fromNode.edges, toId) !== -1;\r\n  }\r\n\r\n  removeCorner(nodeId: number, x: number, y: number) {\r\n    const node = this.getNode(nodeId);\r\n\r\n    if (node) {\r\n      const idx = findCorner(node.corners, x, y);\r\n\r\n      if (idx !== -1) {\r\n        node.corners.splice(idx, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  addCorner(nodeId: number, x: number, y: number) {\r\n    const node = this.getNode(nodeId);\r\n\r\n    if (node) {\r\n      node.corners.push({ x, y });\r\n    }\r\n  }\r\n\r\n  serialize() {\r\n    // for (let i = 0; i < this.nodes.length; ++i) {\r\n    //   console.log(`Node ${i}`);\r\n    //   for (let j = 0; j < this.nodes[i].edges.length; ++j) {\r\n    //     const node = this.nodes[i].edges[j];\r\n    //     console.log(`  Edge -> ${node.nodeId} ${node.data ? `(${JSON.stringify(node.data)})` : ''}`);\r\n    //   }\r\n    // }\r\n\r\n    return JSON.stringify({\r\n      nodes: this.nodes,\r\n      width: this.width,\r\n      height: this.height\r\n    });\r\n  }\r\n\r\n  static unserialize(data: string) {\r\n    const d = JSON.parse(data);\r\n    const g = new Graph(d.nodes.length, d.width, d.height);\r\n\r\n    g.nodes = d.nodes;\r\n\r\n    return g;\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/Graph.js","//@flow\r\n\r\nlet steps = [\r\n  {\r\n    title: 'Generating similarity graph',\r\n    progress: 0\r\n  },\r\n  {\r\n    title: 'Resolving ambiguous diagonals',\r\n    progress: 0\r\n  },\r\n  {\r\n    title: 'Computing reshaped graph',\r\n    progress: 0\r\n  }\r\n];\r\n\r\nconst Progressor = {};\r\n\r\nProgressor.reset = () => {\r\n  for (let i = 0; i < steps.length; ++i) {\r\n    steps[i].progress = 0;\r\n  }\r\n};\r\n\r\nProgressor.progress = (step: number, percent: number) => {\r\n  if (steps[step]) {\r\n    steps[step].progress = percent;\r\n  }\r\n};\r\n\r\nProgressor.done = () => {\r\n  for (let i = 0; i < steps.length; ++i) {\r\n    steps[i].progress = 100;\r\n  }\r\n};\r\n\r\nProgressor.getProgression = () => {\r\n  let p = 0;\r\n  let title = null;\r\n\r\n  for (let i = 0; i < steps.length; ++i) {\r\n    p += steps[i].progress;\r\n\r\n    if (!title && steps[i].progress !== 100) {\r\n      title = steps[i].title;\r\n    }\r\n  }\r\n\r\n  const total = Math.floor(p / steps.length);\r\n\r\n  return {\r\n    title: total === 100 ? '' : title || steps[0].title,\r\n    percent: total,\r\n    complete: total === 100\r\n  };\r\n};\r\n\r\nexport default Progressor;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/Progressor.js"],"sourceRoot":""}