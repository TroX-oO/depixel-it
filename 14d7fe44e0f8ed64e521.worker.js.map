{"version":3,"sources":["../14d7fe44e0f8ed64e521.worker.js","../webpack/bootstrap 14d7fe44e0f8ed64e521","worker/ImageProcessor.js","lib/Graph.js","lib/Shape.js","lib/Node.js","helpers/Progressor.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_interopRequireDefault","obj","default","onProgress","step","percent","_Progressor2","progress","getProgression","lastProgress","post","type","data","createSimilarityGraph","width","height","g","_Graph2","j","current","rgb","r","b","nodes","x","y","addEdge","Math","floor","toYUV","ceil","u","v","match","rgb1","rgb2","removeDissimilarConnectedPixels","graph","length","edges","yuv1","dest","nodeId","yuv2","abs","removeEdge","computeCurveHeuristic","fromId","toId","stack","curve","push","pop","edge","indexOf","getbounds","x1","y1","x2","y2","xMin","min","yMin","xMax","yMax","inbounds","bounds","computeSparseHeuristic","component","neigh","neighId","node","computeIslandHeuristic","computeWeight","result","mostWeightDiagonals","origin","wFirst","wSecond","from","to","removeDiagonals","hasEdge","diag","reshape","gr","makeGrid","_nodes$i","id","px_x","max","px_y","offsetX","offsetY","adj_node","findNode","pn","mpn","npn","mpnNode","npnNode","pxNode","pnNode","removeCorner","addCorner","addNode","removals","_gr$nodes$_i","removeNode","clone","JSON","parse","stringify","corners","processImage","binaryData","serialize","reshapedGraph","shapes","dump","handleMessage","e","binary","console","log","reset","image","done","_Graph","_Progressor","postMessage","onmessage","_classCallCheck","instance","Constructor","TypeError","findEdge","findNodeIdx","findCorner","value","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","_Shape","_Shape2","Id","Graph","size","this","Array","idx","splice","dir","fromNode","getNode","toNode","seen","shape","addPoint","edgeId","edgeNode","_Node","_Node2","Shape","points","first","unshift","sortByAngle","a","angleA","atan2","angleB","Node","sort","bind","steps","title","Progressor","total","complete"],"mappings":"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","file":"14d7fe44e0f8ed64e521.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/depixel-it/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nvar _Graph=__webpack_require__(1);var _Graph2=_interopRequireDefault(_Graph);var _Progressor=__webpack_require__(4);var _Progressor2=_interopRequireDefault(_Progressor);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}//$FlowFixMe\nvar post=postMessage;var lastProgress=0;function onProgress(step,percent){if((step||step===0)&&(percent||percent===0)){_Progressor2.default.progress(step,percent);}var p=_Progressor2.default.getProgression();if(lastProgress!==p.percent){lastProgress=p.percent;post({type:'progress',data:p});}}function createSimilarityGraph(data,width,height){var g=new _Graph2.default(width*height,width,height);for(var j=0;j<height;j++){for(var i=0;i<width;i++){var current=j*width+i;var rgb={r:data[current*4],g:data[current*4+1],b:data[current*4+2]};// We set node color\ng.nodes[current].rgb=rgb;g.nodes[current].x=i;g.nodes[current].y=j;// Adding edges to horizontal/vertical neighbours\nif(i<width-1){// Right\ng.addEdge(current,current+1,'right');if(j>0){// Up Right\ng.addEdge(current,current-width+1,'upright');}if(j<height-1){// Down Right\ng.addEdge(current,current+width+1,'downright');}}if(i>0){// Left\ng.addEdge(current,current-1,'left');if(j>0){// Up Right\ng.addEdge(current,current-width-1,'upleft');}if(j<height-1){// Down Left\ng.addEdge(current,current+width-1,'downleft');}}if(j<height-1){// Down\ng.addEdge(current,current+width,'down');}if(j>0){// Up\ng.addEdge(current,current-width,'up');}onProgress(0,Math.floor(current/(height*width-1)*100));}}return g;}function toYUV(rgb){var y=Math.ceil(0.299*rgb.r+0.587*rgb.g+0.114*rgb.b);var u=Math.ceil(rgb.r*-0.168736+rgb.g*-0.331264+rgb.b*0.5+128);var v=Math.ceil(rgb.r*0.5+rgb.g*-0.418688+rgb.b*-0.081312+128);return{y:y,u:u,v:v};}function match(rgb1,rgb2){return rgb1.r===rgb2.r&&rgb1.g===rgb2.g&&rgb1.b===rgb2.b;}function removeDissimilarConnectedPixels(graph){var nodes=graph.nodes;for(var i=0;i<nodes.length;++i){var edges=nodes[i].edges;var yuv1=toYUV(nodes[i].rgb);for(var j=0;j<edges.length;++j){var dest=nodes[edges[j].nodeId];var yuv2=toYUV(dest.rgb);if(Math.abs(yuv1.y-yuv2.y)>48/255||Math.abs(yuv1.u-yuv2.u)>7/255||Math.abs(yuv1.v-yuv2.v)>6/255){graph.removeEdge(i,edges[j].nodeId);--j;}}onProgress(1,Math.floor(i/(nodes.length-1)*100));}}function computeCurveHeuristic(graph,fromId,toId,width){var nodes=graph.nodes;var stack=[];var curve=[fromId+'-'+toId];stack.push(fromId);stack.push(toId);while(stack.length){var nodeId=stack.pop();var edges=nodes[nodeId].edges;// If we have more or less than 2 edges, then it's not part of a curve\nif(edges.length!==2){continue;}for(var i=0;i<edges.length;++i){var edge=edges[i];// If we have not seen this edge in the curve\nif(curve.indexOf(nodeId+'-'+edge.nodeId)===-1&&curve.indexOf(edge.nodeId+'-'+nodeId)===-1){// We add it to the stack\ncurve.push(nodeId+'-'+edge.nodeId);stack.push(edge.nodeId);}}}return curve.length;}function getbounds(fromId,toId,width,height){var FrameSize=8;var x1=fromId%width;var y1=Math.floor(fromId/width);var x2=toId%width;var y2=Math.floor(toId/width);var xMin=-FrameSize/2-1+Math.min(x1,x2);var yMin=-FrameSize/2-1+Math.min(y1,y2);return{xMin:xMin,yMin:yMin,xMax:xMin+FrameSize,yMax:yMin+FrameSize};}function inbounds(bounds,x,y){var xMin=bounds.xMin,yMin=bounds.yMin,xMax=bounds.xMax,yMax=bounds.yMax;return x>=xMin&&x<=xMax&&y>=yMin&&y<=yMax;}function computeSparseHeuristic(graph,fromId,toId,width,height){var stack=[];var component=[fromId,toId];var bounds=getbounds(fromId,toId,width,height);stack.push(fromId);stack.push(toId);while(stack.length){var nodeId=stack.pop();var neigh=graph.nodes[nodeId].edges;for(var i=0;i<neigh.length;++i){var neighId=neigh[i].nodeId;if(component.indexOf(neighId)===-1){// If the node is within the 8x8 bounds\nvar node=graph.nodes[neighId];if(inbounds(bounds,node.x,node.y)){// We add it to the stack\ncomponent.push(neighId);stack.push(neighId);}}}}return-component.length;}function computeIslandHeuristic(graph,fromId,toId,width){var nodes=graph.nodes;if(nodes[fromId].edges.length===1||nodes[toId].edges.length===1){return 5;}return 0;}function computeWeight(graph,fromId,toId,width,height){var result=0;result+=computeCurveHeuristic(graph,fromId,toId,width);result+=computeSparseHeuristic(graph,fromId,toId,width,height);result+=computeIslandHeuristic(graph,fromId,toId,width);return result;}function mostWeightDiagonals(graph,origin,width,height){var wFirst=computeWeight(graph,origin,origin+width+1,width,height);var wSecond=computeWeight(graph,origin+1,origin+width,width,height);if(wFirst>wSecond){return{from:origin+1,to:origin+width};}else if(wFirst<wSecond){return{from:origin,to:origin+width+1};}return null;}function removeDiagonals(graph,width,height){var nodes=graph.nodes;for(var i=0;i<nodes.length;++i){// We check if the 2x2 block is fully connected\n// Checking from current to the right/down/downright\n// Checking from current + 1 to down/downleft\n// checking from current + width to right\nif(graph.hasEdge(i,i+1)&&graph.hasEdge(i,i+width)&&graph.hasEdge(i,i+width+1)&&graph.hasEdge(i+1,i+width)&&graph.hasEdge(i+1,i+width+1)&&graph.hasEdge(i+width,i+width+1)){// We remove diagonales\ngraph.removeEdge(i,i+width+1);graph.removeEdge(i+1,i+width);}else if(!graph.hasEdge(i,i+1)&&!graph.hasEdge(i,i+width)&&graph.hasEdge(i,i+width+1)&&graph.hasEdge(i+1,i+width)&&!graph.hasEdge(i+1,i+width+1)&&!graph.hasEdge(i+width,i+width+1)){// Diagonals only, we need to resolve ambiguous meaning\nvar diag=mostWeightDiagonals(graph,i,width,height);if(diag){// We remove the most weighted diag\ngraph.removeEdge(diag.from,diag.to);}else{// If it's a tie, we remove both\ngraph.removeEdge(i,i+width+1);graph.removeEdge(i+1,i+width);}}onProgress(2,Math.floor(i/(nodes.length-1)*100));}}function reshape(graph,width,height){var gr=new _Graph2.default((width+1)*(height+1),width+1,height+1);var nodes=graph.nodes;gr.makeGrid(width,height);for(var i=0;i<nodes.length;++i){var _nodes$i=nodes[i],edges=_nodes$i.edges,x=_nodes$i.x,y=_nodes$i.y,rgb=_nodes$i.rgb,id=_nodes$i.id;// we don't process corners\nif(x===0&&y===0||x===0&&y===height-1||x===width-1&&y===0||x===width-1&&y===height-1){continue;}for(var j=0;j<edges.length;++j){var edge=edges[j];var to=nodes[edge.nodeId];// We check only diagonals\nif(x===to.x||y===to.y){continue;}var px_x=Math.max(to.x,x);var px_y=Math.max(to.y,y);var offsetX=to.x-x;var offsetY=to.y-y;// Adj node = to.x, y\nvar adj_node=graph.findNode(to.x,y);var pn=null;var mpn=null;var npn=null;var mpnNode=null;var npnNode=null;var pxNode=null;var pnNode=null;if(!match(rgb,adj_node.rgb)){pn=[px_x,px_y-offsetY];mpn=[px_x,px_y-0.5*offsetY];npn=[px_x+0.25*offsetX,px_y-0.25*offsetY];graph.removeCorner(adj_node.id,px_x,px_y);graph.addCorner(adj_node.id,npn[0],npn[1]);graph.addCorner(id,npn[0],npn[1]);mpnNode=gr.findNode(mpn[0],mpn[1]);npnNode=gr.findNode(npn[0],npn[1]);pxNode=gr.findNode(px_x,px_y);if(mpnNode){gr.removeEdge(mpnNode.id,pxNode.id);}else{pnNode=gr.findNode(pn[0],pn[1]);gr.removeEdge(pnNode.id,pxNode.id);mpnNode=gr.addNode(mpn[0],mpn[1]);gr.addEdge(pnNode.id,mpnNode.id);}if(!npnNode){npnNode=gr.addNode(npn[0],npn[1]);}gr.addEdge(mpnNode.id,npnNode.id);gr.addEdge(npnNode.id,pxNode.id);}// Adj node = to.x, y\nadj_node=graph.findNode(x,to.y);if(!match(rgb,adj_node.rgb)){pn=[px_x-offsetX,px_y];mpn=[px_x-0.5*offsetX,px_y];npn=[px_x-0.25*offsetX,px_y+0.25*offsetY];graph.removeCorner(adj_node.id,px_x,px_y);graph.addCorner(adj_node.id,npn[0],npn[1]);graph.addCorner(id,npn[0],npn[1]);mpnNode=gr.findNode(mpn[0],mpn[1]);npnNode=gr.findNode(npn[0],npn[1]);pxNode=gr.findNode(px_x,px_y);if(mpnNode){gr.removeEdge(mpnNode.id,pxNode.id);}else{pnNode=gr.findNode(pn[0],pn[1]);gr.removeEdge(pnNode.id,pxNode.id);mpnNode=gr.addNode(mpn[0],mpn[1]);gr.addEdge(pnNode.id,mpnNode.id);}if(!npnNode){npnNode=gr.addNode(npn[0],npn[1]);}gr.addEdge(mpnNode.id,npnNode.id);gr.addEdge(npnNode.id,pxNode.id);}}onProgress(3,Math.floor(i/(nodes.length-1)*100));}// We optimize the graph by removing 2-valences nodes\nvar removals=[];for(var _i=0;_i<gr.nodes.length;++_i){var _gr$nodes$_i=gr.nodes[_i],edges=_gr$nodes$_i.edges,x=_gr$nodes$_i.x,y=_gr$nodes$_i.y,id=_gr$nodes$_i.id;if(x===0&&y===0||x===0&&y===height||x===width&&y===0||x===width&&y===height){continue;}if(edges.length===2){gr.addEdge(edges[0].nodeId,edges[1].nodeId);}if(edges.length<=2){removals.push(id);}}for(var _i2=0;_i2<removals.length;++_i2){gr.removeNode(removals[_i2]);}// Copying corners\nfor(var _i3=0;_i3<nodes.length;++_i3){var clone=JSON.parse(JSON.stringify(nodes[_i3].corners));for(var _j=0;_j<clone.length;++_j){if(!gr.findNode(clone[_j].x,clone[_j].y)){graph.removeCorner(_i3,clone[_j].x,clone[_j].y);}}}return gr;}function processImage(binaryData,width,height){var graph=createSimilarityGraph(binaryData,width,height);post({type:'step',data:{type:'initial',graph:graph.serialize()}});removeDissimilarConnectedPixels(graph);post({type:'step',data:{type:'initial',graph:graph.serialize()}});removeDiagonals(graph,width,height);post({type:'step',data:{type:'initial',graph:graph.serialize()}});var reshapedGraph=reshape(graph,width,height);post({type:'step',data:{type:'initial',graph:graph.serialize()}});post({type:'step',data:{type:'reshaped',graph:reshapedGraph.serialize()}});post({type:'step',data:{type:'shapes',graph:graph.serialize()}});var shapes=graph.shapes();for(var i=0;i<shapes.length;++i){shapes[i].dump();}}function handleMessage(e){var width=e.data.width;var height=e.data.height;var binary=e.data.data;console.log('Message received from main script.');console.log(e.data);lastProgress=0;_Progressor2.default.reset();processImage(binary,width,height);post({type:'step',data:{type:'final',image:binary}});_Progressor2.default.done();onProgress();}onmessage=handleMessage;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _Shape=__webpack_require__(2);var _Shape2=_interopRequireDefault(_Shape);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function findEdge(node,toId){for(var i=0;i<node.length;++i){if(node[i].nodeId===toId){return i;}}return-1;}function findNodeIdx(nodes,nodeId){for(var i=0;i<nodes.length;++i){if(nodes[i].id===nodeId){return i;}}return-1;}function findCorner(corners,x,y){for(var i=0;i<corners.length;++i){if(corners[i].x===x&&corners[i].y===y){return i;}}return-1;}var Id=0;var Graph=function(){function Graph(size,width,height){_classCallCheck(this,Graph);this.id=++Id;this.nodes=new Array(size);this.width=width;this.height=height;for(var i=0;i<this.nodes.length;++i){var _x=i%width;var _y=Math.floor(i/width);this.nodes[i]={id:i,edges:[],rgb:null,x:-1,y:-1,corners:[{x:_x,y:_y}]};if(_x<width){this.nodes[i].corners.push({x:_x+1,y:_y});}if(_y<height){this.nodes[i].corners.push({x:_x,y:_y+1});}if(_x<width&&_y<height){this.nodes[i].corners.push({x:_x+1,y:_y+1});}}}_createClass(Graph,[{key:'makeGrid',value:function makeGrid(width,height){var nodes=this.nodes;for(var i=0;i<nodes.length;++i){var _x2=i%(width+1);var _y2=Math.floor(i/(width+1));nodes[i].x=_x2;nodes[i].y=_y2;nodes[i].corners=[];if(_x2<width){this.addEdge(i,i+1,'right');}if(_y2<height){this.addEdge(i,i+(width+1),'down');}}}},{key:'addNode',value:function addNode(x,y){var n=this.findNode(x,y);if(!n){n={id:this.nodes.length,edges:[],rgb:null,x:x,y:y,corners:[]};this.nodes.push(n);}return n;}},{key:'removeNode',value:function removeNode(nodeId){var idx=findNodeIdx(this.nodes,nodeId);if(idx!==-1){var node=this.nodes[idx];while(node.edges.length){this.removeEdge(nodeId,node.edges[0].nodeId);}this.nodes.splice(idx,1);}}},{key:'findNode',value:function findNode(x,y){for(var i=0;i<this.nodes.length;++i){if(this.nodes[i].x===x&&this.nodes[i].y===y){return this.nodes[i];}}return null;}},{key:'getNode',value:function getNode(nodeId){for(var i=0;i<this.nodes.length;++i){if(this.nodes[i].id===nodeId){return this.nodes[i];}}return null;}},{key:'addEdge',value:function addEdge(fromId,toId,dir,data){var fromNode=this.getNode(fromId);var toNode=this.getNode(toId);if(fromNode&&findEdge(fromNode.edges,toId)===-1){fromNode.edges.push({nodeId:toId,dir:dir,data:data});}if(toNode&&findEdge(toNode.edges,fromId)===-1){var invert=function invert(dir){if(dir==='up')return'down';if(dir==='down')return'up';if(dir==='left')return'right';if(dir==='right')return'left';if(dir==='upright')return'downleft';if(dir==='upleft')return'downright';if(dir==='downleft')return'upright';if(dir==='downright')return'upleft';};toNode.edges.push({nodeId:fromId,dir:invert(dir),data:data});}}},{key:'removeEdge',value:function removeEdge(fromId,toId){var fromNode=this.getNode(fromId);var toNode=this.getNode(toId);if(fromNode){var idx=findEdge(fromNode.edges,toId);if(idx!==-1){fromNode.edges.splice(idx,1);}}if(toNode){var _idx=findEdge(toNode.edges,fromId);if(_idx!==-1){toNode.edges.splice(_idx,1);}}}},{key:'hasEdge',value:function hasEdge(fromId,toId){var fromNode=this.getNode(fromId);return findEdge(fromNode.edges,toId)!==-1;}},{key:'removeCorner',value:function removeCorner(nodeId,x,y){var node=this.getNode(nodeId);if(node){var idx=findCorner(node.corners,x,y);if(idx!==-1){node.corners.splice(idx,1);}}}},{key:'addCorner',value:function addCorner(nodeId,x,y){var node=this.getNode(nodeId);if(node){if(findCorner(node.corners,x,y)===-1){node.corners.push({x:x,y:y});}}}},{key:'shapes',value:function shapes(){var nodes=this.nodes;var shapes=[];var seen=[];for(var i=0;i<nodes.length;++i){var node=nodes[i];if(seen.indexOf(node.id)!==-1){continue;}var shape=new _Shape2.default();var stack=[node.id];seen.push(node.id);shape.addPoint(node.x,node.y,node.rgb,node.corners);while(stack.length){var _id=stack.pop();var n=nodes[_id];for(var j=0;j<n.edges.length;++j){var edgeId=n.edges[j].nodeId;var edgeNode=nodes[edgeId];if(seen.indexOf(edgeId)===-1){stack.push(edgeId);seen.push(edgeId);shape.addPoint(edgeNode.x,edgeNode.y,edgeNode.rgb,edgeNode.corners);}}}shapes.push(shape);}return shapes;}},{key:'serialize',value:function serialize(){// for (let i = 0; i < this.nodes.length; ++i) {\n//   console.log(`Node ${i}`);\n//   for (let j = 0; j < this.nodes[i].edges.length; ++j) {\n//     const node = this.nodes[i].edges[j];\n//     console.log(`  Edge -> ${node.nodeId} ${node.data ? `(${JSON.stringify(node.data)})` : ''}`);\n//   }\n// }\nreturn JSON.stringify({nodes:this.nodes,width:this.width,height:this.height});}}],[{key:'unserialize',value:function unserialize(data){var d=JSON.parse(data);var g=new Graph(d.nodes.length,d.width,d.height);g.nodes=d.nodes;return g;}}]);return Graph;}();exports.default=Graph;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _Node=__webpack_require__(3);var _Node2=_interopRequireDefault(_Node);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}var Shape=function(){function Shape(){_classCallCheck(this,Shape);this.points=[];}_createClass(Shape,[{key:'addPoint',value:function addPoint(x,y,rgb,corners){// We always add the top-left point in first to skip a step in the\n// computation of convex hull\nvar p=new _Node2.default(x,y,rgb,corners);var first=this.points[0];if(!first||first.x<=p.x){this.points.push(p);}else{this.points.unshift(p);}}},{key:'computeConvexHull',value:function computeConvexHull(){}},{key:'dump',value:function dump(){console.log('Shape of '+this.points.length+' points.');for(var i=0;i<this.points.length;++i){var p=this.points[i];console.log('('+p.x+', '+p.y+') rgb: '+JSON.stringify(p.rgb)+' corners: '+JSON.stringify(p.corners));}}}]);return Shape;}();exports.default=Shape;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function sortByAngle(x,y,a,b){var angleA=Math.atan2(a.y-y,a.x-x);var angleB=Math.atan2(b.y-y,b.x-x);console.log('angleA ('+x+', '+y+') -> ('+a.x+', '+a.y+'): '+angleA+' | angleB ('+x+', '+y+') -> ('+b.x+', '+b.y+'): '+angleB);if(angleA<angleB){return-1;}if(angleA>angleB){return 1;}return 0;}var Node=function Node(x,y,rgb,corners){_classCallCheck(this,Node);this.x=x;this.y=y;this.rgb=rgb;console.log(' in => '+JSON.stringify(corners));this.corners=corners?corners.sort(sortByAngle.bind(null,x+0.5,y+0.5)):[];console.log(' out => '+JSON.stringify(this.corners));};exports.default=Node;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});var steps=[{title:'Generating similarity graph',progress:0},{title:'Removing dissimilar connected pixels',progress:0},{title:'Resolving ambiguous diagonals',progress:0},{title:'Computing reshaped graph',progress:0}];var done=false;var Progressor={};Progressor.reset=function(){for(var i=0;i<steps.length;++i){steps[i].progress=0;}done=false;};Progressor.progress=function(step,percent){if(steps[step]){steps[step].progress=percent;}};Progressor.done=function(){for(var i=0;i<steps.length;++i){steps[i].progress=100;}done=true;};Progressor.getProgression=function(){var p=0;var title=null;for(var i=0;i<steps.length;++i){p+=steps[i].progress;if(!title&&steps[i].progress!==100){title=steps[i].title;}}var total=Math.floor(p/steps.length);return{title:total===100?'':title||steps[0].title,percent:total,complete:done};};exports.default=Progressor;\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// 14d7fe44e0f8ed64e521.worker.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/depixel-it/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 14d7fe44e0f8ed64e521","import Graph from '../lib/Graph';\r\nimport Progressor from '../helpers/Progressor';\r\n\r\n//@flow\r\n\r\n//$FlowFixMe\r\nconst post = postMessage;\r\nlet lastProgress = 0;\r\n\r\nfunction onProgress(step?: number, percent?: number) {\r\n  if ((step || step === 0) && (percent || percent === 0)) {\r\n    Progressor.progress(step, percent);\r\n  }\r\n  const p = Progressor.getProgression();\r\n\r\n  if (lastProgress !== p.percent) {\r\n    lastProgress = p.percent;\r\n\r\n    post({\r\n      type: 'progress',\r\n      data: p\r\n    });\r\n  }\r\n}\r\n\r\nfunction createSimilarityGraph(data, width, height) {\r\n  const g = new Graph(width * height, width, height);\r\n\r\n  for (let j = 0; j < height; j++) {\r\n    for (let i = 0; i < width; i++) {\r\n      const current = j * width + i;\r\n      const rgb = {\r\n        r: data[current * 4],\r\n        g: data[current * 4 + 1],\r\n        b: data[current * 4 + 2]\r\n      };\r\n\r\n      // We set node color\r\n      g.nodes[current].rgb = rgb;\r\n      g.nodes[current].x = i;\r\n      g.nodes[current].y = j;\r\n\r\n      // Adding edges to horizontal/vertical neighbours\r\n      if (i < width - 1) {\r\n        // Right\r\n        g.addEdge(current, current + 1, 'right');\r\n\r\n        if (j > 0) {\r\n          // Up Right\r\n          g.addEdge(current, current - width + 1, 'upright');\r\n        }\r\n        if (j < height - 1) {\r\n          // Down Right\r\n          g.addEdge(current, current + width + 1, 'downright');\r\n        }\r\n      }\r\n      if (i > 0) {\r\n        // Left\r\n        g.addEdge(current, current - 1, 'left');\r\n\r\n        if (j > 0) {\r\n          // Up Right\r\n          g.addEdge(current, current - width - 1, 'upleft');\r\n        }\r\n        if (j < height - 1) {\r\n          // Down Left\r\n          g.addEdge(current, current + width - 1, 'downleft');\r\n        }\r\n      }\r\n\r\n      if (j < height - 1) {\r\n        // Down\r\n        g.addEdge(current, current + width, 'down');\r\n      }\r\n      if (j > 0) {\r\n        // Up\r\n        g.addEdge(current, current - width, 'up');\r\n      }\r\n      onProgress(0, Math.floor(current / (height * width - 1) * 100));\r\n    }\r\n  }\r\n\r\n  return g;\r\n}\r\n\r\nfunction toYUV(rgb: Object) {\r\n  const y = Math.ceil(0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b);\r\n  const u = Math.ceil(rgb.r * -0.168736 + rgb.g * -0.331264 + rgb.b * 0.5 + 128);\r\n  const v = Math.ceil(rgb.r * 0.5 + rgb.g * -0.418688 + rgb.b * -0.081312 + 128);\r\n\r\n  return {\r\n    y,\r\n    u,\r\n    v\r\n  };\r\n}\r\n\r\nfunction match(rgb1, rgb2) {\r\n  return rgb1.r === rgb2.r && rgb1.g === rgb2.g && rgb1.b === rgb2.b;\r\n}\r\n\r\nfunction removeDissimilarConnectedPixels(graph) {\r\n  const { nodes } = graph;\r\n\r\n  for (let i = 0; i < nodes.length; ++i) {\r\n    const edges = nodes[i].edges;\r\n    const yuv1 = toYUV(nodes[i].rgb);\r\n\r\n    for (let j = 0; j < edges.length; ++j) {\r\n      const dest = nodes[edges[j].nodeId];\r\n      const yuv2 = toYUV(dest.rgb);\r\n\r\n      if (\r\n        Math.abs(yuv1.y - yuv2.y) > 48 / 255 ||\r\n        Math.abs(yuv1.u - yuv2.u) > 7 / 255 ||\r\n        Math.abs(yuv1.v - yuv2.v) > 6 / 255\r\n      ) {\r\n        graph.removeEdge(i, edges[j].nodeId);\r\n        --j;\r\n      }\r\n    }\r\n    onProgress(1, Math.floor(i / (nodes.length - 1) * 100));\r\n  }\r\n}\r\n\r\nfunction computeCurveHeuristic(graph, fromId, toId, width) {\r\n  const { nodes } = graph;\r\n  const stack = [];\r\n  const curve = [`${fromId}-${toId}`];\r\n\r\n  stack.push(fromId);\r\n  stack.push(toId);\r\n\r\n  while (stack.length) {\r\n    const nodeId = stack.pop();\r\n    const { edges } = nodes[nodeId];\r\n\r\n    // If we have more or less than 2 edges, then it's not part of a curve\r\n    if (edges.length !== 2) {\r\n      continue;\r\n    }\r\n\r\n    for (let i = 0; i < edges.length; ++i) {\r\n      const edge = edges[i];\r\n\r\n      // If we have not seen this edge in the curve\r\n      if (curve.indexOf(`${nodeId}-${edge.nodeId}`) === -1 && curve.indexOf(`${edge.nodeId}-${nodeId}`) === -1) {\r\n        // We add it to the stack\r\n        curve.push(`${nodeId}-${edge.nodeId}`);\r\n        stack.push(edge.nodeId);\r\n      }\r\n    }\r\n  }\r\n  return curve.length;\r\n}\r\n\r\nfunction getbounds(fromId, toId, width, height) {\r\n  const FrameSize = 8;\r\n  const x1 = fromId % width;\r\n  const y1 = Math.floor(fromId / width);\r\n  const x2 = toId % width;\r\n  const y2 = Math.floor(toId / width);\r\n  const xMin = -FrameSize / 2 - 1 + Math.min(x1, x2);\r\n  const yMin = -FrameSize / 2 - 1 + Math.min(y1, y2);\r\n\r\n  return {\r\n    xMin,\r\n    yMin,\r\n    xMax: xMin + FrameSize,\r\n    yMax: yMin + FrameSize\r\n  };\r\n}\r\n\r\nfunction inbounds(bounds, x, y) {\r\n  const { xMin, yMin, xMax, yMax } = bounds;\r\n\r\n  return x >= xMin && x <= xMax && y >= yMin && y <= yMax;\r\n}\r\n\r\nfunction computeSparseHeuristic(graph, fromId, toId, width, height) {\r\n  const stack = [];\r\n  const component = [fromId, toId];\r\n  const bounds = getbounds(fromId, toId, width, height);\r\n\r\n  stack.push(fromId);\r\n  stack.push(toId);\r\n\r\n  while (stack.length) {\r\n    const nodeId = stack.pop();\r\n    const neigh = graph.nodes[nodeId].edges;\r\n\r\n    for (let i = 0; i < neigh.length; ++i) {\r\n      const neighId = neigh[i].nodeId;\r\n\r\n      if (component.indexOf(neighId) === -1) {\r\n        // If the node is within the 8x8 bounds\r\n        const node = graph.nodes[neighId];\r\n        if (inbounds(bounds, node.x, node.y)) {\r\n          // We add it to the stack\r\n          component.push(neighId);\r\n          stack.push(neighId);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return -component.length;\r\n}\r\n\r\nfunction computeIslandHeuristic(graph, fromId, toId, width) {\r\n  const { nodes } = graph;\r\n\r\n  if (nodes[fromId].edges.length === 1 || nodes[toId].edges.length === 1) {\r\n    return 5;\r\n  }\r\n  return 0;\r\n}\r\n\r\nfunction computeWeight(graph, fromId, toId, width, height) {\r\n  let result = 0;\r\n\r\n  result += computeCurveHeuristic(graph, fromId, toId, width);\r\n  result += computeSparseHeuristic(graph, fromId, toId, width, height);\r\n  result += computeIslandHeuristic(graph, fromId, toId, width);\r\n\r\n  return result;\r\n}\r\n\r\nfunction mostWeightDiagonals(graph, origin, width, height) {\r\n  const wFirst = computeWeight(graph, origin, origin + width + 1, width, height);\r\n  const wSecond = computeWeight(graph, origin + 1, origin + width, width, height);\r\n\r\n  if (wFirst > wSecond) {\r\n    return {\r\n      from: origin + 1,\r\n      to: origin + width\r\n    };\r\n  } else if (wFirst < wSecond) {\r\n    return {\r\n      from: origin,\r\n      to: origin + width + 1\r\n    };\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction removeDiagonals(graph, width, height) {\r\n  const { nodes } = graph;\r\n\r\n  for (let i = 0; i < nodes.length; ++i) {\r\n    // We check if the 2x2 block is fully connected\r\n    // Checking from current to the right/down/downright\r\n    // Checking from current + 1 to down/downleft\r\n    // checking from current + width to right\r\n    if (\r\n      graph.hasEdge(i, i + 1) &&\r\n      graph.hasEdge(i, i + width) &&\r\n      graph.hasEdge(i, i + width + 1) &&\r\n      graph.hasEdge(i + 1, i + width) &&\r\n      graph.hasEdge(i + 1, i + width + 1) &&\r\n      graph.hasEdge(i + width, i + width + 1)\r\n    ) {\r\n      // We remove diagonales\r\n      graph.removeEdge(i, i + width + 1);\r\n      graph.removeEdge(i + 1, i + width);\r\n    } else if (\r\n      !graph.hasEdge(i, i + 1) &&\r\n      !graph.hasEdge(i, i + width) &&\r\n      graph.hasEdge(i, i + width + 1) &&\r\n      graph.hasEdge(i + 1, i + width) &&\r\n      !graph.hasEdge(i + 1, i + width + 1) &&\r\n      !graph.hasEdge(i + width, i + width + 1)\r\n    ) {\r\n      // Diagonals only, we need to resolve ambiguous meaning\r\n      const diag = mostWeightDiagonals(graph, i, width, height);\r\n\r\n      if (diag) {\r\n        // We remove the most weighted diag\r\n        graph.removeEdge(diag.from, diag.to);\r\n      } else {\r\n        // If it's a tie, we remove both\r\n        graph.removeEdge(i, i + width + 1);\r\n        graph.removeEdge(i + 1, i + width);\r\n      }\r\n    }\r\n    onProgress(2, Math.floor(i / (nodes.length - 1) * 100));\r\n  }\r\n}\r\n\r\nfunction reshape(graph, width, height) {\r\n  const gr = new Graph((width + 1) * (height + 1), width + 1, height + 1);\r\n  const { nodes } = graph;\r\n\r\n  gr.makeGrid(width, height);\r\n\r\n  for (let i = 0; i < nodes.length; ++i) {\r\n    const { edges, x, y, rgb, id } = nodes[i];\r\n\r\n    // we don't process corners\r\n    if (\r\n      (x === 0 && y === 0) ||\r\n      (x === 0 && y === height - 1) ||\r\n      (x === width - 1 && y === 0) ||\r\n      (x === width - 1 && y === height - 1)\r\n    ) {\r\n      continue;\r\n    }\r\n\r\n    for (let j = 0; j < edges.length; ++j) {\r\n      const edge = edges[j];\r\n      const to = nodes[edge.nodeId];\r\n\r\n      // We check only diagonals\r\n      if (x === to.x || y === to.y) {\r\n        continue;\r\n      }\r\n\r\n      const px_x = Math.max(to.x, x);\r\n      const px_y = Math.max(to.y, y);\r\n      const offsetX = to.x - x;\r\n      const offsetY = to.y - y;\r\n\r\n      // Adj node = to.x, y\r\n      let adj_node = graph.findNode(to.x, y);\r\n\r\n      let pn = null;\r\n      let mpn = null;\r\n      let npn = null;\r\n      let mpnNode = null;\r\n      let npnNode = null;\r\n      let pxNode = null;\r\n      let pnNode = null;\r\n\r\n      if (!match(rgb, adj_node.rgb)) {\r\n        pn = [px_x, px_y - offsetY];\r\n        mpn = [px_x, px_y - 0.5 * offsetY];\r\n        npn = [px_x + 0.25 * offsetX, px_y - 0.25 * offsetY];\r\n\r\n        graph.removeCorner(adj_node.id, px_x, px_y);\r\n        graph.addCorner(adj_node.id, npn[0], npn[1]);\r\n        graph.addCorner(id, npn[0], npn[1]);\r\n\r\n        mpnNode = gr.findNode(mpn[0], mpn[1]);\r\n        npnNode = gr.findNode(npn[0], npn[1]);\r\n        pxNode = gr.findNode(px_x, px_y);\r\n\r\n        if (mpnNode) {\r\n          gr.removeEdge(mpnNode.id, pxNode.id);\r\n        } else {\r\n          pnNode = gr.findNode(pn[0], pn[1]);\r\n\r\n          gr.removeEdge(pnNode.id, pxNode.id);\r\n          mpnNode = gr.addNode(mpn[0], mpn[1]);\r\n          gr.addEdge(pnNode.id, mpnNode.id);\r\n        }\r\n        if (!npnNode) {\r\n          npnNode = gr.addNode(npn[0], npn[1]);\r\n        }\r\n        gr.addEdge(mpnNode.id, npnNode.id);\r\n        gr.addEdge(npnNode.id, pxNode.id);\r\n      }\r\n\r\n      // Adj node = to.x, y\r\n      adj_node = graph.findNode(x, to.y);\r\n\r\n      if (!match(rgb, adj_node.rgb)) {\r\n        pn = [px_x - offsetX, px_y];\r\n        mpn = [px_x - 0.5 * offsetX, px_y];\r\n        npn = [px_x - 0.25 * offsetX, px_y + 0.25 * offsetY];\r\n\r\n        graph.removeCorner(adj_node.id, px_x, px_y);\r\n        graph.addCorner(adj_node.id, npn[0], npn[1]);\r\n        graph.addCorner(id, npn[0], npn[1]);\r\n\r\n        mpnNode = gr.findNode(mpn[0], mpn[1]);\r\n        npnNode = gr.findNode(npn[0], npn[1]);\r\n        pxNode = gr.findNode(px_x, px_y);\r\n\r\n        if (mpnNode) {\r\n          gr.removeEdge(mpnNode.id, pxNode.id);\r\n        } else {\r\n          pnNode = gr.findNode(pn[0], pn[1]);\r\n\r\n          gr.removeEdge(pnNode.id, pxNode.id);\r\n          mpnNode = gr.addNode(mpn[0], mpn[1]);\r\n          gr.addEdge(pnNode.id, mpnNode.id);\r\n        }\r\n        if (!npnNode) {\r\n          npnNode = gr.addNode(npn[0], npn[1]);\r\n        }\r\n        gr.addEdge(mpnNode.id, npnNode.id);\r\n        gr.addEdge(npnNode.id, pxNode.id);\r\n      }\r\n    }\r\n    onProgress(3, Math.floor(i / (nodes.length - 1) * 100));\r\n  }\r\n\r\n  // We optimize the graph by removing 2-valences nodes\r\n  const removals = [];\r\n\r\n  for (let i = 0; i < gr.nodes.length; ++i) {\r\n    const { edges, x, y, id } = gr.nodes[i];\r\n\r\n    if (\r\n      (x === 0 && y === 0) ||\r\n      (x === 0 && y === height) ||\r\n      (x === width && y === 0) ||\r\n      (x === width && y === height)\r\n    ) {\r\n      continue;\r\n    }\r\n\r\n    if (edges.length === 2) {\r\n      gr.addEdge(edges[0].nodeId, edges[1].nodeId);\r\n    }\r\n    if (edges.length <= 2) {\r\n      removals.push(id);\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < removals.length; ++i) {\r\n    gr.removeNode(removals[i]);\r\n  }\r\n\r\n  // Copying corners\r\n  for (let i = 0; i < nodes.length; ++i) {\r\n    const clone = JSON.parse(JSON.stringify(nodes[i].corners));\r\n\r\n    for (let j = 0; j < clone.length; ++j) {\r\n      if (!gr.findNode(clone[j].x, clone[j].y)) {\r\n        graph.removeCorner(i, clone[j].x, clone[j].y);\r\n      }\r\n    }\r\n  }\r\n\r\n  return gr;\r\n}\r\n\r\nfunction processImage(binaryData, width, height) {\r\n  const graph = createSimilarityGraph(binaryData, width, height);\r\n\r\n  post({\r\n    type: 'step',\r\n    data: {\r\n      type: 'initial',\r\n      graph: graph.serialize()\r\n    }\r\n  });\r\n\r\n  removeDissimilarConnectedPixels(graph);\r\n\r\n  post({\r\n    type: 'step',\r\n    data: {\r\n      type: 'initial',\r\n      graph: graph.serialize()\r\n    }\r\n  });\r\n\r\n  removeDiagonals(graph, width, height);\r\n\r\n  post({\r\n    type: 'step',\r\n    data: {\r\n      type: 'initial',\r\n      graph: graph.serialize()\r\n    }\r\n  });\r\n\r\n  const reshapedGraph = reshape(graph, width, height);\r\n\r\n  post({\r\n    type: 'step',\r\n    data: {\r\n      type: 'initial',\r\n      graph: graph.serialize()\r\n    }\r\n  });\r\n\r\n  post({\r\n    type: 'step',\r\n    data: {\r\n      type: 'reshaped',\r\n      graph: reshapedGraph.serialize()\r\n    }\r\n  });\r\n\r\n  post({\r\n    type: 'step',\r\n    data: {\r\n      type: 'shapes',\r\n      graph: graph.serialize()\r\n    }\r\n  });\r\n\r\n  const shapes = graph.shapes();\r\n\r\n  for (let i = 0; i < shapes.length; ++i) {\r\n    shapes[i].dump();\r\n  }\r\n}\r\n\r\nfunction handleMessage(e: any) {\r\n  const width = e.data.width;\r\n  const height = e.data.height;\r\n  const binary = e.data.data;\r\n  console.log('Message received from main script.');\r\n  console.log(e.data);\r\n\r\n  lastProgress = 0;\r\n  Progressor.reset();\r\n\r\n  processImage(binary, width, height);\r\n  post({\r\n    type: 'step',\r\n    data: {\r\n      type: 'final',\r\n      image: binary\r\n    }\r\n  });\r\n\r\n  Progressor.done();\r\n  onProgress();\r\n}\r\n\r\nonmessage = handleMessage;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/worker/ImageProcessor.js","import Shape from './Shape';\r\n\r\n//@flow\r\n\r\nfunction findEdge(node: Array<Object>, toId: number) {\r\n  for (let i = 0; i < node.length; ++i) {\r\n    if (node[i].nodeId === toId) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n\r\nfunction findNodeIdx(nodes: Array<Object>, nodeId: number) {\r\n  for (let i = 0; i < nodes.length; ++i) {\r\n    if (nodes[i].id === nodeId) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n\r\nfunction findCorner(corners: Array<Object>, x: number, y: number) {\r\n  for (let i = 0; i < corners.length; ++i) {\r\n    if (corners[i].x === x && corners[i].y === y) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n\r\nlet Id = 0;\r\n\r\nexport default class Graph {\r\n  id: number;\r\n  nodes: Array<{\r\n    id: number,\r\n    edges: Array<Object>,\r\n    corners: Array<Object>,\r\n    rgb: ?Object,\r\n    x: number,\r\n    y: number\r\n  }>;\r\n  width: number;\r\n  height: number;\r\n\r\n  constructor(size: number, width: number, height: number) {\r\n    this.id = ++Id;\r\n    this.nodes = new Array(size);\r\n    this.width = width;\r\n    this.height = height;\r\n\r\n    for (let i = 0; i < this.nodes.length; ++i) {\r\n      const x = i % width;\r\n      const y = Math.floor(i / width);\r\n      this.nodes[i] = {\r\n        id: i,\r\n        edges: [],\r\n        rgb: null,\r\n        x: -1,\r\n        y: -1,\r\n        corners: [{ x, y }]\r\n      };\r\n\r\n      if (x < width) {\r\n        this.nodes[i].corners.push({ x: x + 1, y: y });\r\n      }\r\n      if (y < height) {\r\n        this.nodes[i].corners.push({ x: x, y: y + 1 });\r\n      }\r\n\r\n      if (x < width && y < height) {\r\n        this.nodes[i].corners.push({ x: x + 1, y: y + 1 });\r\n      }\r\n    }\r\n  }\r\n\r\n  makeGrid(width: number, height: number) {\r\n    const { nodes } = this;\r\n\r\n    for (let i = 0; i < nodes.length; ++i) {\r\n      const x = i % (width + 1);\r\n      const y = Math.floor(i / (width + 1));\r\n\r\n      nodes[i].x = x;\r\n      nodes[i].y = y;\r\n\r\n      nodes[i].corners = [];\r\n\r\n      if (x < width) {\r\n        this.addEdge(i, i + 1, 'right');\r\n      }\r\n      if (y < height) {\r\n        this.addEdge(i, i + (width + 1), 'down');\r\n      }\r\n    }\r\n  }\r\n\r\n  addNode(x: number, y: number) {\r\n    let n = this.findNode(x, y);\r\n\r\n    if (!n) {\r\n      n = { id: this.nodes.length, edges: [], rgb: null, x, y, corners: [] };\r\n\r\n      this.nodes.push(n);\r\n    }\r\n    return n;\r\n  }\r\n\r\n  removeNode(nodeId: number) {\r\n    const idx = findNodeIdx(this.nodes, nodeId);\r\n\r\n    if (idx !== -1) {\r\n      const node = this.nodes[idx];\r\n\r\n      while (node.edges.length) {\r\n        this.removeEdge(nodeId, node.edges[0].nodeId);\r\n      }\r\n\r\n      this.nodes.splice(idx, 1);\r\n    }\r\n  }\r\n\r\n  findNode(x: number, y: number) {\r\n    for (let i = 0; i < this.nodes.length; ++i) {\r\n      if (this.nodes[i].x === x && this.nodes[i].y === y) {\r\n        return this.nodes[i];\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  getNode(nodeId: number) {\r\n    for (let i = 0; i < this.nodes.length; ++i) {\r\n      if (this.nodes[i].id === nodeId) {\r\n        return this.nodes[i];\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  addEdge(fromId: number, toId: number, dir: string, data: any) {\r\n    const fromNode = this.getNode(fromId);\r\n    const toNode = this.getNode(toId);\r\n\r\n    if (fromNode && findEdge(fromNode.edges, toId) === -1) {\r\n      fromNode.edges.push({ nodeId: toId, dir, data });\r\n    }\r\n    if (toNode && findEdge(toNode.edges, fromId) === -1) {\r\n      const invert = dir => {\r\n        if (dir === 'up') return 'down';\r\n        if (dir === 'down') return 'up';\r\n        if (dir === 'left') return 'right';\r\n        if (dir === 'right') return 'left';\r\n        if (dir === 'upright') return 'downleft';\r\n        if (dir === 'upleft') return 'downright';\r\n        if (dir === 'downleft') return 'upright';\r\n        if (dir === 'downright') return 'upleft';\r\n      };\r\n      toNode.edges.push({ nodeId: fromId, dir: invert(dir), data });\r\n    }\r\n  }\r\n\r\n  removeEdge(fromId: number, toId: number) {\r\n    const fromNode = this.getNode(fromId);\r\n    const toNode = this.getNode(toId);\r\n\r\n    if (fromNode) {\r\n      const idx = findEdge(fromNode.edges, toId);\r\n\r\n      if (idx !== -1) {\r\n        fromNode.edges.splice(idx, 1);\r\n      }\r\n    }\r\n\r\n    if (toNode) {\r\n      const idx = findEdge(toNode.edges, fromId);\r\n\r\n      if (idx !== -1) {\r\n        toNode.edges.splice(idx, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  hasEdge(fromId: number, toId: number) {\r\n    const fromNode = this.getNode(fromId);\r\n    return findEdge(fromNode.edges, toId) !== -1;\r\n  }\r\n\r\n  removeCorner(nodeId: number, x: number, y: number) {\r\n    const node = this.getNode(nodeId);\r\n\r\n    if (node) {\r\n      const idx = findCorner(node.corners, x, y);\r\n\r\n      if (idx !== -1) {\r\n        node.corners.splice(idx, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  addCorner(nodeId: number, x: number, y: number) {\r\n    const node = this.getNode(nodeId);\r\n\r\n    if (node) {\r\n      if (findCorner(node.corners, x, y) === -1) {\r\n        node.corners.push({ x, y });\r\n      }\r\n    }\r\n  }\r\n\r\n  shapes(): Array<Shape> {\r\n    const nodes = this.nodes;\r\n    const shapes = [];\r\n    const seen = [];\r\n\r\n    for (let i = 0; i < nodes.length; ++i) {\r\n      const node = nodes[i];\r\n\r\n      if (seen.indexOf(node.id) !== -1) {\r\n        continue;\r\n      }\r\n\r\n      const shape = new Shape();\r\n      const stack = [node.id];\r\n\r\n      seen.push(node.id);\r\n      shape.addPoint(node.x, node.y, node.rgb, node.corners);\r\n\r\n      while (stack.length) {\r\n        const id = stack.pop();\r\n        const n = nodes[id];\r\n\r\n        for (let j = 0; j < n.edges.length; ++j) {\r\n          const edgeId = n.edges[j].nodeId;\r\n          const edgeNode = nodes[edgeId];\r\n\r\n          if (seen.indexOf(edgeId) === -1) {\r\n            stack.push(edgeId);\r\n            seen.push(edgeId);\r\n            shape.addPoint(edgeNode.x, edgeNode.y, edgeNode.rgb, edgeNode.corners);\r\n          }\r\n        }\r\n      }\r\n      shapes.push(shape);\r\n    }\r\n\r\n    return shapes;\r\n  }\r\n\r\n  serialize() {\r\n    // for (let i = 0; i < this.nodes.length; ++i) {\r\n    //   console.log(`Node ${i}`);\r\n    //   for (let j = 0; j < this.nodes[i].edges.length; ++j) {\r\n    //     const node = this.nodes[i].edges[j];\r\n    //     console.log(`  Edge -> ${node.nodeId} ${node.data ? `(${JSON.stringify(node.data)})` : ''}`);\r\n    //   }\r\n    // }\r\n\r\n    return JSON.stringify({\r\n      nodes: this.nodes,\r\n      width: this.width,\r\n      height: this.height\r\n    });\r\n  }\r\n\r\n  static unserialize(data: string) {\r\n    const d = JSON.parse(data);\r\n    const g = new Graph(d.nodes.length, d.width, d.height);\r\n\r\n    g.nodes = d.nodes;\r\n\r\n    return g;\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/Graph.js","import Node from './Node';\r\n\r\n//@flow\r\n\r\nexport default class Shape {\r\n  points: Array<Node>;\r\n\r\n  constructor() {\r\n    this.points = [];\r\n  }\r\n\r\n  addPoint(x: number, y: number, rgb: Object, corners: Array<Object>) {\r\n    // We always add the top-left point in first to skip a step in the\r\n    // computation of convex hull\r\n    const p = new Node(x, y, rgb, corners);\r\n    const first = this.points[0];\r\n\r\n    if (!first || first.x <= p.x) {\r\n      this.points.push(p);\r\n    } else {\r\n      this.points.unshift(p);\r\n    }\r\n  }\r\n\r\n  computeConvexHull() {}\r\n\r\n  dump() {\r\n    console.log(`Shape of ${this.points.length} points.`);\r\n    for (let i = 0; i < this.points.length; ++i) {\r\n      const p = this.points[i];\r\n\r\n      console.log(`(${p.x}, ${p.y}) rgb: ${JSON.stringify(p.rgb)} corners: ${JSON.stringify(p.corners)}`);\r\n    }\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/Shape.js","//@flow\r\n\r\nexport type Point = {\r\n  x: number,\r\n  y: number\r\n};\r\n\r\nfunction sortByAngle(x: number, y: number, a: Point, b: Point): number {\r\n  const angleA = Math.atan2(a.y - y, a.x - x);\r\n  const angleB = Math.atan2(b.y - y, b.x - x);\r\n\r\n  console.log(\r\n    `angleA (${x}, ${y}) -> (${a.x}, ${a.y}): ${angleA} | angleB (${x}, ${y}) -> (${b.x}, ${b.y}): ${angleB}`\r\n  );\r\n  if (angleA < angleB) {\r\n    return -1;\r\n  }\r\n  if (angleA > angleB) {\r\n    return 1;\r\n  }\r\n  return 0;\r\n}\r\n\r\nexport default class Node {\r\n  x: number;\r\n  y: number;\r\n  rgb: Object;\r\n  corners: Array<Point>;\r\n\r\n  constructor(x: number, y: number, rgb: Object, corners?: Array<Point>) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.rgb = rgb;\r\n    console.log(' in => ' + JSON.stringify(corners));\r\n    this.corners = corners ? corners.sort(sortByAngle.bind(null, x + 0.5, y + 0.5)) : [];\r\n    console.log(' out => ' + JSON.stringify(this.corners));\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/Node.js","//@flow\r\n\r\nlet steps = [\r\n  {\r\n    title: 'Generating similarity graph',\r\n    progress: 0\r\n  },\r\n  {\r\n    title: 'Removing dissimilar connected pixels',\r\n    progress: 0\r\n  },\r\n  {\r\n    title: 'Resolving ambiguous diagonals',\r\n    progress: 0\r\n  },\r\n  {\r\n    title: 'Computing reshaped graph',\r\n    progress: 0\r\n  }\r\n];\r\nlet done = false;\r\n\r\nconst Progressor = {};\r\n\r\nProgressor.reset = () => {\r\n  for (let i = 0; i < steps.length; ++i) {\r\n    steps[i].progress = 0;\r\n  }\r\n  done = false;\r\n};\r\n\r\nProgressor.progress = (step: number, percent: number) => {\r\n  if (steps[step]) {\r\n    steps[step].progress = percent;\r\n  }\r\n};\r\n\r\nProgressor.done = () => {\r\n  for (let i = 0; i < steps.length; ++i) {\r\n    steps[i].progress = 100;\r\n  }\r\n  done = true;\r\n};\r\n\r\nProgressor.getProgression = () => {\r\n  let p = 0;\r\n  let title = null;\r\n\r\n  for (let i = 0; i < steps.length; ++i) {\r\n    p += steps[i].progress;\r\n\r\n    if (!title && steps[i].progress !== 100) {\r\n      title = steps[i].title;\r\n    }\r\n  }\r\n\r\n  const total = Math.floor(p / steps.length);\r\n\r\n  return {\r\n    title: total === 100 ? '' : title || steps[0].title,\r\n    percent: total,\r\n    complete: done\r\n  };\r\n};\r\n\r\nexport default Progressor;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/Progressor.js"],"sourceRoot":""}